### Django + Vue.js 实战派 Python Web 开发与运维



### 第 1 篇 基础



#### 第 1 章 走进 Django



Django可以让你以更快的速度、更少的代码、更轻松的方式搭建更好的Web应用。



##### 1.1 了解 Django



###### 1.1.1 Django 发展历史和版本



- 2003 诞生



https://www.djangoproject.com/download/



![image-20240930164846650](./assets/image-20240930164846650.png)





###### 1.1.2 MVC 和 MVT 模式



- MVC：

    - M：模型
    - V：视图
    - C：控制器

  ![image-20240930165338268](./assets/image-20240930165338268.png)

- MVT：（Django 修改）

    - M：模型
    - T：模板
    - V：视图

  还有一个 URL 分发器

  ![image-20240930165420699](./assets/image-20240930165420699.png)





##### 1.2  安装 Django



###### 1.2.1 安装 Python 虚拟环境



我就用 conda 了



- Python：`3.8.2`



![image-20240930170231775](./assets/image-20240930170231775.png)



###### 1.2.2 Windows 安装 Django



- Django：3.1.5



![image-20240930171038535](./assets/image-20240930171038535.png)



##### 1.3 用 VsCode 编辑器进行 Django 开发



我就不了，我直接用 pycharm 了



##### 1.4 【实战】开发第 1 个 Django 应用



###### 1.4.1 创建项目



`django-admin startproject myshop`



![image-20240930171356536](./assets/image-20240930171356536.png)



![image-20240930171433530](./assets/image-20240930171433530.png)



![image-20240930171630543](./assets/image-20240930171630543.png)



手动改了下名字



![image-20240930171453448](./assets/image-20240930171453448.png)



###### 1.4.2 创建应用



`python manage.py startapp app1`



app1 应用目录结构：



![image-20240930171648445](./assets/image-20240930171648445.png)



含义：

![image-20240930171658113](./assets/image-20240930171658113.png)



注册应用



![image-20240930171852887](./assets/image-20240930171852887.png)



直接上 IDE 了



![image-20240930171923428](./assets/image-20240930171923428.png)



只要是通过 `startapp` 命令创建的应用，都需要注册



###### 1.4.3 处理控制器



1. 处理视图的动态逻辑

   ![image-20240930172116987](./assets/image-20240930172116987.png)

2. 处理 URL 请求路径

   ![image-20240930172150162](./assets/image-20240930172150162.png)





###### 1.4.4 处理模板



1. 创建模板目录和模板文件



![image-20240930172318295](./assets/image-20240930172318295.png)



2. 配置全局设置文件



![image-20240930172417620](./assets/image-20240930172417620.png)



###### 1.4.5 运行应用



![image-20240930172452654](./assets/image-20240930172452654.png)



访问：



![image-20240930172527049](./assets/image-20240930172527049.png)



没问题





##### 1.5 Django 项目的运行和调试



###### 1.5.1 设置运行环境



略

![image-20240930172619192](./assets/image-20240930172619192.png)



###### 1.5.2 调试项目



断点调试，略



#### 第 2 章 网站的入口 —— Djang 的路由和视图



##### 2.1 认识路由



项目路由其实会帮助我们创建，但是应用的 urls.py 需要手动来



###### 2.1.1 路由系统的基本配置



`urlpatterns` 的列表：存放项目的 URL 路由规则



![image-20240930172836399](./assets/image-20240930172836399.png)





一个path（）函数对应一条路由规则。

语法格式：

```
path(url正则表达式，视图函数，别名)
```





###### 2.1.2 【实战】用 “路由包含” 简化项目的复杂度



1. 路由配置规则



在项目的urls文件中，urlpatterns列表会从上到下进行匹配。【如果有子路由，那就用 `include` 加载】

路由信息一般以 `/` 结尾



2. 实战



又来了一个 app2 ，还是同样的方式



![image-20240930173735137](./assets/image-20240930173735137.png)



![image-20240930173824440](./assets/image-20240930173824440.png)



![image-20240930173830181](./assets/image-20240930173830181.png)



![image-20240930173836328](./assets/image-20240930173836328.png)



访问



![image-20240930173758938](./assets/image-20240930173758938.png)



![image-20240930173811325](./assets/image-20240930173811325.png)



###### 2.1.3 解析路由参数





1. 编写带 URL 参数的路由



![image-20240930174317734](./assets/image-20240930174317734.png)



添加视图



![image-20240930174148662](./assets/image-20240930174148662.png)



运行结果

![image-20240930174331756](./assets/image-20240930174331756.png)





2. 介绍 URL 参数



`<参数数据类型: 参数名称>`



![image-20240930174501181](./assets/image-20240930174501181.png)





3. URL 参数解析的加强实例



![image-20240930174743637](./assets/image-20240930174743637.png)



![image-20240930174915723](./assets/image-20240930174915723.png)



效果



![image-20240930174956314](./assets/image-20240930174956314.png)



![image-20240930175009144](./assets/image-20240930175009144.png)



###### 2.1.4 【实战】用 re_path() 方法正则匹配复杂路由



re_path()方法和path()方法的作用一样。

在re_path()方法中编写URL时可以使用正则表达式，所以其功能更强大。



1. 路由中的正则表达式



语法：

`(?P<name>pattern)`

其中，name是匹配的字符串的名称，pattern是要匹配的模式。



![image-20240930175155162](./assets/image-20240930175155162.png)



2. 实例



![image-20240930175359078](./assets/image-20240930175359078.png)



添加视图



![image-20240930175741725](./assets/image-20240930175741725.png)



效果



![image-20240930175823029](./assets/image-20240930175823029.png)



![image-20240930175850349](./assets/image-20240930175850349.png)



###### 2.1.5 反向解析路由



在Django的路由配置中，可以给一个路由配置项命名，然后在视图函数或模板的HTML文件中进行调用。



1. 介绍



`    path('app2/url_reverse/',views.url_reverse,name='app2_url_reverse'),`



说明：

- name 后可跟任意字符串。一般规范：应用名_配置项名称



根据name得到路由配置项中的 URL 地址，称作 反向解析路由。好处：name 不变，URL 地址可以任意改变



2. 实例



![image-20240930180144845](./assets/image-20240930180144845.png)



![image-20240930180235640](./assets/image-20240930180235640.png)



新建模板：

![image-20240930180310581](./assets/image-20240930180310581.png)



效果



![image-20240930180401511](./assets/image-20240930180401511.png)



没问题





##### 2.2 认识视图函数



在视图中使用函数处理请求，被称为视图函数，也叫作 FBV。



###### 2.2.1 什么是视图函数



![image-20240930180656729](./assets/image-20240930180656729.png)



视图函数默认接收一个 HttpRequest 对象为第一个参数。





###### 2.2.2 视图函数的底层原理



1. HttpRequest 对象

   ![image-20240930180815683](./assets/image-20240930180815683.png)

   ![image-20240930180844807](./assets/image-20240930180844807.png)

   配置路由

   ![image-20240930180916115](./assets/image-20240930180916115.png)

   效果

   ![image-20240930180948017](./assets/image-20240930180948017.png)

   试试 post

   ![image-20240930181019867](./assets/image-20240930181019867.png)

   ![image-20240930181047450](./assets/image-20240930181047450.png)

   路由

   ![image-20240930181118502](./assets/image-20240930181118502.png)

   效果

   ![image-20240930181208031](./assets/image-20240930181208031.png)

2. HttpResponse 对象

   常用属性

   ![image-20240930181228699](./assets/image-20240930181228699.png)

   常用状态码

   ![image-20240930181241658](./assets/image-20240930181241658.png)

   ![image-20240930181314744](./assets/image-20240930181314744.png)

   路由

   ![image-20240930181342717](./assets/image-20240930181342717.png)

   效果

   ![image-20240930181410148](./assets/image-20240930181410148.png)





###### 2.2.3 视图处理函数的使用



通过HttpRequest对象和HttpResponse对象，可以处理基本的数据请求并返回响应数据。

但是繁琐。



Django 封装了：



1. 用 render 函数实现页面渲染



render() 函数，根据模板文件和传递给模板文件的字典类型的变量，生成一个HttpResponse对象并返回。



![image-20240930181602912](./assets/image-20240930181602912.png)



路由

![image-20240930181657469](./assets/image-20240930181657469.png)



新建模板

![image-20240930181716842](./assets/image-20240930181716842.png)



效果



![image-20240930181802087](./assets/image-20240930181802087.png)



中文有点乱码



2. 用 redirect 函数实现页面重定向



在Django中，使用重定向函数redirect()实现网页重定向。



（1）通过调用模型的 get_absolute_url 函数进行重定向

添加一个 模型类



![image-20240930182056157](./assets/image-20240930182056157.png)



来吧，直接数据迁移【记得注册 app2 】



![image-20240930182400097](./assets/image-20240930182400097.png)



特喵，没注册都能直接使用接口 ...

添加视图

![image-20240930182630173](./assets/image-20240930182630173.png)



路由



![image-20240930182716731](./assets/image-20240930182716731.png)



效果



![image-20240930182844608](./assets/image-20240930182844608.png)



表里随便插一条数据



![image-20240930183112677](./assets/image-20240930183112677-1727692275185-4.png)



302 确实重定向了



没毛病，这是调用了模型类的 get_absolute_url 方法



![image-20240930183545716](./assets/image-20240930183545716.png)



加了个输出，效果更明显



![image-20240930183603574](./assets/image-20240930183603574.png)



（2）通过路由反向解析进行重定向



添加视图

![image-20240930183311147](./assets/image-20240930183311147.png)



这种方式和 reverse 效果是一样的



路由

![image-20240930183340618](./assets/image-20240930183340618.png)



效果

![image-20240930183403185](./assets/image-20240930183403185.png)



没问题，确实 302 直接重定向了



（3）通过一个绝对或相对的 URL， 让浏览器跳转



![image-20240930183704845](./assets/image-20240930183704845.png)



路由



![image-20240930183730137](./assets/image-20240930183730137.png)



效果



![image-20240930183748643](./assets/image-20240930183748643.png)



没问题





##### 2.3 认识视图类



Django框架还提供了另外一种处理用户请求的方式 —— 视图类的处理方式。



###### 2.3.1 什么是视图类



在视图里使用类处理方式，被称为视图类(class base views，CBV)。



→ 面向对象



###### 2.3.2 对比视图函数和视图类



用 方法 代替 if 判断。



视图类在调用时，只能是函数的方式，而不能是类的方式。因此，需要将视图类用`as_view`转化为视图函数。



###### 2.3.3 利用视图类进行功能设计



常用的视图类：



1. 通用视图类 —— TemplateView

   视图类

   ![image-20240930184245504](./assets/image-20240930184245504.png)

   模板

   ![image-20240930184326290](./assets/image-20240930184326290.png)



路由

![image-20240930184444569](./assets/image-20240930184444569.png)

看看效果

![image-20240930184530687](./assets/image-20240930184530687.png)

比较简单

2. 列表视图类 —— ListView

   视图类

   ![image-20240930185352350](./assets/image-20240930185352350.png)

   模板

   ![image-20240930184650770](./assets/image-20240930184650770.png)

   路由

   ![image-20240930184714077](./assets/image-20240930184714077.png)

   效果

   ![image-20240930202126622](./assets/image-20240930202126622.png)

   没找到原因，为什么时间类型数据拿不到

3. 详细视图类 —— DetailView

   视图类

   ![image-20240930202556489](./assets/image-20240930202556489.png)

   模板

   ![image-20240930202658048](./assets/image-20240930202658048.png)

   路由

   ![image-20240930202722792](./assets/image-20240930202722792.png)

   效果

   ![image-20240930202748362](./assets/image-20240930202748362.png)

   时间还是拿不出来

   【这里自己解决一下】

   ![image-20240930210020405](./assets/image-20240930210020405.png)

   勉强看吧

   ![image-20240930210058699](./assets/image-20240930210058699.png)

   原因是数据库的问题

   ![image-20240930210124100](./assets/image-20240930210124100.png)





#### 第 3 章 页面展现 —— 基于 Django 模板



Django模板技术作为MTV模式中的T(Template),主要用于页面的展现。

可以分为两部分：

- 静态部分：HTML、CSS和JavaScript
- 动态部分：Django 的模板语言 DTL





##### 3.1 Django 模板语言 —— DTL



DTL：Django 自带的模板语言

Django 模板语言包括模板变量、模板标签和模板过滤器。



###### 3.1.1 模板变量



模板变量，除可以是字符串外，还可以是列表、字典和类对象。【HTML 文件占位符】



1. 模板变量的表示

`{{ 变量名 }}` 表示



2. 实例



视图函数

![image-20240930210408674](./assets/image-20240930210408674.png)



模板

![image-20240930210500989](./assets/image-20240930210500989.png)



路由

![image-20240930210607913](./assets/image-20240930210607913.png)



效果

![image-20240930210841563](./assets/image-20240930210841563.png)



合适的



###### 3.1.2 模板标签



模板标签需要用标签限定符`{% %}`进行包裹。

模板标签的作用：载入代码渲染模板，或对传递过来的参数进行逻辑判断和计算。



![image-20240930210912573](./assets/image-20240930210912573.png)



1. 条件判断模板标签

   ![image-20240930210952233](./assets/image-20240930210952233.png)

   ![image-20240930210957672](./assets/image-20240930210957672.png)

   意思就是根据不同的条件输出不同的内容

   注意：运算符前后不能紧挨变量或常量，必须有空格

2. 循环模板标签

   循环模板标签`{% for %}` 用来遍历一个序列或者可迭代对象，如列表、字典、字符串等

   还有一些标签变量

   ![image-20240930211100531](./assets/image-20240930211100531.png)

   视图

   ![image-20240930211127340](./assets/image-20240930211127340.png)

   模板

   ![image-20240930211150271](./assets/image-20240930211150271.png)

   路由

   ![image-20240930211215700](./assets/image-20240930211215700.png)

   效果

   ![image-20240930211235311](./assets/image-20240930211235311.png)

   没毛病





###### 3.1.3 模板过滤器



模板过滤器用于对模板变量进行操作。



1. 介绍



语法格式：`{{ 变量名 | 过滤器: 参数 }}`

常用：



![image-20240930211331627](./assets/image-20240930211331627.png)



2. 实例



视图



![image-20240930211432700](./assets/image-20240930211432700.png)



模板

![image-20240930211459495](./assets/image-20240930211459495.png)



路由

![image-20240930211524281](./assets/image-20240930211524281.png)



效果



![image-20240930211606082](./assets/image-20240930211606082.png)





##### 3.2 模板的高级用法



###### 3.2.1 模板转义



Django 的模板会对 HTML 标签和 JavaScript 标签进行自动转义，这样做是为了代码的安全



实例：

视图

![image-20240930211820287](./assets/image-20240930211820287.png)



模板

![image-20240930211844287](./assets/image-20240930211844287.png)



路由

![image-20240930211904938](./assets/image-20240930211904938.png)



效果



![image-20240930211938706](./assets/image-20240930211938706.png)



使用 safe 过滤器可以关闭模板转义，从而正常地解析HTML代码。



###### 3.2.2 【实战】自定义过滤器



1. 准备工作



![image-20240930212126785](./assets/image-20240930212126785.png)





2. 编写自定义过滤器并注册



![image-20240930212200974](./assets/image-20240930212200974.png)



@register.filter 是一个装饰器，指明 show_title 函数是一个过滤器。



3. 加载自定义过滤器并编写模板



视图

![image-20240930212322583](./assets/image-20240930212322583.png)



模板

![image-20240930212344437](./assets/image-20240930212344437.png)



路由

![image-20240930212402446](./assets/image-20240930212402446.png)



效果



![image-20240930212439344](./assets/image-20240930212439344.png)



没毛病



###### 3.2.3 【实战】自定义标签



自定义标签比过滤器功能强大，但是实现起来相对复杂。如果Django内置的标签不能满足需求，则可以通过自定义标签的方式来实现。



- 简单标签
- 包含标签





1. 简单标签



新建文件

![image-20240930212627740](./assets/image-20240930212627740.png)



视图

![image-20240930212649722](./assets/image-20240930212649722.png)



模板

![image-20240930212713320](./assets/image-20240930212713320.png)



路由

![image-20240930212734849](./assets/image-20240930212734849.png)



效果



![image-20240930212750142](./assets/image-20240930212750142.png)



效果一样



2. 包含标签



增加自定义标签



![image-20240930212848527](./assets/image-20240930212848527.png)



模板

![image-20240930212908665](./assets/image-20240930212908665.png)



视图

![image-20240930212932122](./assets/image-20240930212932122.png)



模板

![image-20240930212952500](./assets/image-20240930212952500.png)



路由



![image-20240930213011977](./assets/image-20240930213011977.png)



效果



![image-20240930213027594](./assets/image-20240930213027594.png)



没毛病



##### 3.3 模板继承



简单来说，模板继承就是建立一个基础的模板（也被称为“母版页”）。该母版页包含网站常见的元素，并且定义了一系列可以被内容页覆盖的“块”(block)。

一个网站会有很多页面，如果多个页面有相同的部分，则可以将相同的部分抽取出来制作成一个母版页，这样可以实现代码的重用、提高开发效率。



> 类似于 Vue 组件那种 style



母版页 + 内容页 一起形成一张独立的网页



###### 3.3.1 设计母版页



![image-20240930213210764](./assets/image-20240930213210764.png)



###### 3.3.2 设计内容页



![image-20240930213242251](./assets/image-20240930213242251.png)



注意：extends标签必须是内容页中的第1行代码。



视图

![image-20240930213320662](./assets/image-20240930213320662.png)



路由

![image-20240930213342227](./assets/image-20240930213342227.png)



效果



![image-20240930213400826](./assets/image-20240930213400826.png)



没毛病



###### 3.3.3 设计组件



![image-20240930213433291](./assets/image-20240930213433291.png)





![image-20240930213504976](./assets/image-20240930213504976.png)



![image-20240930213515158](./assets/image-20240930213515158.png)



效果



![image-20240930213618984](./assets/image-20240930213618984.png)



效果



![image-20240930214230739](./assets/image-20240930214230739.png)



就是那两个模板的位置要注意



![image-20240930214558024](./assets/image-20240930214558024.png)



这样就能找到了，不然找不到





##### 3.4 配置模板文件



一个网站包含很多个网页，一个网页由HTML、CSS和JavaScript组成。



###### 3.4.1 理解 HTML、CSS 和 JavaScript



HTML是用来描述网页的一种语言，如使用标签（例如`<html></html>`,`<div></div>`)来描述网页。

CSS指层叠样式表，用来定义如何显示HTML元素。层叠样式表一般存放在`.css`文件里。

JavaScript是脚本语言，通过操作HTML中的标签来动态修改页面。





###### 3.4.2 配置静态文件



静态文件包括static和media这两类：

- static：CSS、JavaScript、Images
- media：媒体文件，比如用户上传的文件



在Django中，需要在项目myshop-test的根目录下，手动创建static和media文件夹用来存放对应的静态文件。调试模式和生产模式的配置有所不同。



1. Debug = True

   调试模式，用于调试环境

   ![image-20240930215328644](./assets/image-20240930215328644.png)

2. Debug = False

   生产模式

   ![image-20240930215424683](./assets/image-20240930215424683.png)



修改路由



![image-20240930215726615](./assets/image-20240930215726615.png)



然后就是给了一个页面



![image-20240930221657587](./assets/image-20240930221657587.png)



![image-20240930221704862](./assets/image-20240930221704862.png)



![image-20240930220621906](./assets/image-20240930220621906.png)



样式确实可以出



#### 第 4 章 使用数据库 —— 基于 Django 模型



在 Django 框架中，主要通过模型来实现与数据库的交互功能。



##### 4.1 Django 模型



在Django框架中，模型用于描述数据库表结构。模型实例可以实现数据操作。一个模型Modl)对应一个数据库表。模型中的字段对应数据库表中的一个字段。



###### 4.1.1 定义模型



所有Django模型都必须继承自Model类，Model类位于包django.db.models中。

来吧，`app4`



添加模型类

![image-20240930221825229](./assets/image-20240930221825229.png)



1. 常用模型字段



![image-20240930221851421](./assets/image-20240930221851421.png)



字段类型：



（1）数值型字段 DecimalField

（2）时间日期类型字段





2. 常用字段参数



![image-20240930221959472](./assets/image-20240930221959472.png)



![image-20240930222005622](./assets/image-20240930222005622.png)



3. `__str__()` 方法



`__str__()` 方法用来设置模型的返回值，其默认返回值为“模型对象”。





4. Meta 类



Django模型中的Meta类是一个内部类，用于定义一些Django模型的行为特性。



![image-20240930222118918](./assets/image-20240930222118918.png)



![image-20240930222124374](./assets/image-20240930222124374.png)





###### 4.1.2 了解模型中的关系



数据库中的表存在关联关系，包括“一对一”“一对多”“多对多”关系【Django 模型对应数据库的表，所以 Django 模型也存在这些关系】



1. 一对一关系



在模型中使用 `OneToOneField()`方法来构建

参数：

![image-20240930222230604](./assets/image-20240930222230604.png)



再来一个表

![image-20240930222445437](./assets/image-20240930222445437.png)



这样创建出来的数据表模型关系



![image-20240930222746068](./assets/image-20240930222746068.png)



没啥问题



2. 一对多关系



部门信息表和用户扩展信息表是“一对多”关系。

使用ForeignKey()方法来构建模型的 一对多 关系

参数：



![image-20240930222838370](./assets/image-20240930222838370.png)



添加模型类

![image-20240930222921005](./assets/image-20240930222921005.png)



再在 额外信息表 中关联



![image-20240930222950493](./assets/image-20240930222950493.png)



这样创建出来的模型关系：

![image-20240930223047290](./assets/image-20240930223047290.png)



大概就是这么个意思



3. 多对多关系



用户扩展信息表和技能信息表是“多对多”关系：一个用户可以有多个技能，一个技能也可以对应多个用户。在模型中，用ManyToManyField()方法来构建模型的“多对多”关系。



参数：

![image-20240930223134836](./assets/image-20240930223134836.png)



模型类：

![image-20240930223346663](./assets/image-20240930223346663.png)



没问题，这样建立出来的



![image-20240930223458771](./assets/image-20240930223458771.png)



这样的模型关系



###### 4.1.3 配置项目文件



终于不用 sqlite  了



1. 配置数据库信息



![image-20240930224217010](./assets/image-20240930224217010.png)





2. 配置日志



如果想查看在ORM转换过程中产生的SQL语句

![image-20240930224002772](./assets/image-20240930224002772.png)



###### 4.1.4 迁移数据



代码优先 CodeFirst，代码中直接创建类，框架会根据我们创建的类自动生成数据库和表



1. 生成迁移文件



![image-20240930224504575](./assets/image-20240930224504575.png)





2. 执行迁移



![image-20240930224557635](./assets/image-20240930224557635.png)



![image-20240930224605058](./assets/image-20240930224605058.png)



应该是完成了，看看数据库



![image-20240930224643455](./assets/image-20240930224643455.png)



没问题，确实生成了





3. 生成迁移文件的 SQL 语句



`python manage.py sqlmigrate 应用名称 迁移文件名称（一般就前四位数字）`



![image-20240930224823264](./assets/image-20240930224823264.png)



![image-20240930224837160](./assets/image-20240930224837160.png)



确实生成了



##### 4.2 用 Django 中的 ORM 操作数据库



用 shell 直接在终端测试



![image-20240930225106547](./assets/image-20240930225106547.png)



> 可以装 ipython 库





###### 4.2.1 了解 ORM

ORM的作用：在关系型数据库和业务实体对象之间进行映射。



每个模型都是一个 Python 类，每个模型都会映射到一个 数据库表 上

- 类：数据库中的数据表。
- 属性：数据库中的字段。
- 实例：数据库表中的数据行。



![image-20240930225206292](./assets/image-20240930225206292.png)





###### 4.2.2 熟悉 QuerySet 对象



QuerySet对象也被称为“查询集”，表示从数据库获取的数据对象集合。查询集有一个最重要的特性一惰性执行。

“惰性执行”是指，在创建查询集后不会访问数据库，只有在调用相关方法时才会访问数据库。



1. all 方法



该方法用于获取模型的QuerySet对象，即获取所有的数据。



不行，我觉得我的 ipython 有问题，我直接写个测试类算了，有提示快点



![image-20240930230602712](./assets/image-20240930230602712.png)



![image-20240930230805949](./assets/image-20240930230805949.png)

不知道为什么会出那个错误，但是结果还是出来了



2. filter 方法



该方法用于实现数据过滤功能，相当于SQL语句中的where子句。

![image-20240930230938665](./assets/image-20240930230938665.png)



3. get 方法



该方法用于查询数据表记录，以模型对象的形式返回符合要求的一条数据。

![image-20240930231306754](./assets/image-20240930231306754.png)



4. exclude 方法

该方法用于排除符合条件的数据，返回QuerySet对象。

![image-20240930231349586](./assets/image-20240930231349586.png)



操作符：`age__lt=32` 表示排除所有年龄小于 32 岁的用户，意思是获取 >= 32 的用户



![image-20240930231440779](./assets/image-20240930231440779.png)



filter 和 exclude 中都能用



![image-20240930231533164](./assets/image-20240930231533164.png)



哈哈



5. values 方法

该方法用于提取需要的字段



![image-20240930231711612](./assets/image-20240930231711612.png)



6. distinct 方法

该方法用于去除重复数据



![image-20240930231759868](./assets/image-20240930231759868.png)



###### 4.2.3 查询数据



数据查询主要使用all方法、filter方法、get方法等，以及这些方法的组合。

filter 方法和get 方法都可以完成数据查询的操作。get 方法在找不到数据时会触发异常，提示信息如下。filter 方法则不会有任何提示。



###### 4.2.4 新增数据



新增数据可以通过save()方法和create()方法完成。



1. 使用 save 方法



![image-20240930232241572](./assets/image-20240930232241572.png)



![image-20240930232254552](./assets/image-20240930232254552.png)



2. 使用 create 方法





![image-20240930232409112](./assets/image-20240930232409112.png)



![image-20240930232418574](./assets/image-20240930232418574.png)



或者就直接create ，别分两句



###### 4.2.5 更新数据



更新数据可以使用save方法或者update方法。



![image-20240930232704001](./assets/image-20240930232704001.png)



也可以链式写法

![image-20240930232826141](./assets/image-20240930232826141.png)





还可以批量

![image-20240930232901396](./assets/image-20240930232901396.png)



###### 4.2.6 删除数据



- 删除单行

  `get().delete()`

- 删除多行

  `filter().delete()`

- 删除全部

  `all().delete()`



如果删除的数据有外键字段，且模型中的on delete参数被设置为CASCADE,则删除外键关联表中的对应数据。



###### 4.2.7 操作关联表



1. 一对一关联表的操作



用户基本表和用户扩展表是“一对一”关系，通过关联属性 user 来实现两者之间的关系。



![image-20241001105350136](./assets/image-20241001105350136.png)



添加信息



![image-20241001110241425](./assets/image-20241001110241425.png)



不行，我这儿这个 depart_id 也绑定了，必须传一个



![image-20241001110412609](./assets/image-20241001110412609.png)



看看数据表



![image-20241001110448229](./assets/image-20241001110448229.png)



没什么问题

访问看看



![image-20241001110649265](./assets/image-20241001110649265.png)

其实就已经天然关联起来了

也可以从 额外信息表中获取



![image-20241001110815533](./assets/image-20241001110815533.png)



这都是根据外键来进行的操作



2. 一对多关联表的操作



先看模型类



![image-20241001111008674](./assets/image-20241001111008674.png)



迁移一下



![image-20241001111201446](./assets/image-20241001111201446.png)



新增卡



![image-20241001111329498](./assets/image-20241001111329498.png)



![image-20241001111338374](./assets/image-20241001111338374.png)



再来一张卡



![image-20241001111419298](./assets/image-20241001111419298.png)



![image-20241001111427120](./assets/image-20241001111427120.png)



一对多关系，查一下



![image-20241001111811598](./assets/image-20241001111811598.png)



![image-20241001111818775](./assets/image-20241001111818775.png)



书里面写的有点问题，那儿不能写关系名，不然这种方式查不出来，如果需要用关系名，就是另外一种写法



![image-20241001112015903](./assets/image-20241001112015903.png)



这样也行，但是这两种方式只能用一种



也可以从多查询一



![image-20241001112132619](./assets/image-20241001112132619.png)



没问题



3. 多对多关联表的操作



用户基本表和技能表是“多对多”关系：一个用户可以拥有多项技能，一个技能也可以被多个用户拥有。通过关联属性 user 来实现两者之间的关系。

![image-20241001112621381](./assets/image-20241001112621381.png)



加上技能

![image-20241001112715587](./assets/image-20241001112715587.png)



看看关联表



![image-20241001112730268](./assets/image-20241001112730268.png)



每个用户都加上了id 为 1 的技能

查询一下



![image-20241001112851379](./assets/image-20241001112851379.png)



从用户基本表访问技能表



![image-20241001113352690](./assets/image-20241001113352690.png)



从技能表访问用户基本表



![image-20241001113458267](./assets/image-20241001113458267.png)



这里书上写得好像有问题，注意甄别



修改关联数据，set 方法

![image-20241001114020631](./assets/image-20241001114020631.png)



![image-20241001114055224](./assets/image-20241001114055224.png)



这是直接添加了 三条关联数据



![image-20241001114238048](./assets/image-20241001114238048.png)



执行前后好像没区别，也可以指定用户列表



![image-20241001114345746](./assets/image-20241001114345746.png)



这样 用户 id 为 1,2 ，技能id 为 1 的数据会保留，另外的就删了



删除关联数据，使用 remove 和 clear 方法



![image-20241001114557204](./assets/image-20241001114557204.png)



删除了 skillid 为 1，用户 id 为 1的数据，也可以指定 用户 id



![image-20241001114641850](./assets/image-20241001114641850.png)



没毛病，也可以直接 按照 skill id 直接清除



![image-20241001114731596](./assets/image-20241001114731596.png)



没毛病



4. select_related 方法



在访问某个模型数据时，可以将关联的模型数据提取出来，这样可以减少数据库查询的次数。



![image-20241001115124228](./assets/image-20241001115124228.png)



其实这是查了两次数据库，使用 select_related 方法改写



![image-20241001115245384](./assets/image-20241001115245384.png)



确实只执行了一次

注意：select_related()方法只能用在“一对多”关系且设置了外键的模型中。



5. prefetch_related 方法



和 select_related 类似，解决多对一和多对多关系的查询问题，减少查询次数



![image-20241001115622160](./assets/image-20241001115622160.png)





###### 4.2.8 F() 函数 和 Q() 函数



1. F() 函数



在Django的ORM语句中，F函数用于实现数据表中字段的各种运算操作。



![image-20241001115922710](./assets/image-20241001115922710.png)



所有薪资加上1000 【这种原始操作是把数据都拿出来放在内存里，处理完，再更新到数据库】



此时使用F函数，可以直接生成SQL语句更新数据库

![image-20241001120338877](./assets/image-20241001120338877.png)



使用F 函数更新后，需要使用 refresh_from_db 方法才能获取最新值



![image-20241001120444436](./assets/image-20241001120444436.png)



总结一下：使用F函数可以直接在数据库中进行操作，可以减少某些操作所需的数据库查询次数。



2. Q() 函数



在Diango中的ORM语句中，Q 函数用于对象进行多条件查询，支持 &、|、~

使用Q 函数查询用户扩展表中年龄大于30岁且薪水大于5000元的人员



![image-20241001120657885](./assets/image-20241001120657885.png)



没错，就是李四



###### 4.2.9 执行原生 SQL



Django提供了直接执行SQL语句的方法。



1. Raw 方法



（1）基本使用

![image-20241001120903022](./assets/image-20241001120903022.png)



（2）条件查询

![image-20241001121120428](./assets/image-20241001121120428.png)



（3）多表查询



![image-20241001121300742](./assets/image-20241001121300742.png)



注意：Django使用主键来标识模型实例，因此主键必须始终包含在原始查询中。



2. 游标方法



游标 是系统为用户开设的一个数据缓冲区，主要用于处理和接收数据，如对数据库进行增加、删除、修改和查询等操作。



（1）插入数据



![image-20241001121730458](./assets/image-20241001121730458.png)



（2）查询数据



![image-20241001121840108](./assets/image-20241001121840108.png)



（3）更新数据



![image-20241001122031859](./assets/image-20241001122031859.png)



（4）删除数据



![image-20241001122217199](./assets/image-20241001122217199.png)



###### 4.2.10 事务处理



事务 ACID：

- 原子性
- 一致性
- 隔离性
- 持久性



定义事务有装饰器方式和with语句方式。



1. 装饰器方式



![image-20241001122914893](./assets/image-20241001122914893.png)



2. with 语句方式



![image-20241001122920799](./assets/image-20241001122920799.png)



3. 实例



视图

![image-20241001123105831](./assets/image-20241001123105831.png)



路由



![image-20241001123150270](./assets/image-20241001123150270.png)



![image-20241001123205729](./assets/image-20241001123205729.png)



效果



![image-20241001123319449](./assets/image-20241001123319449.png)



因为我们主动抛出异常了 ，所以回滚



![image-20241001123435244](./assets/image-20241001123435244.png)



如果不抛出

![image-20241001124104195](./assets/image-20241001124104195.png)



![image-20241001124111747](./assets/image-20241001124111747.png)



![image-20241001124129811](./assets/image-20241001124129811.png)



没问题



#### 第 5 章 自动生成界面 —— 基于 Django 表单



Django的模型表单更是在Form表单的基础上，进一步精简了代码，提高了效率。



##### 5.1 HTML 表单



常见的 HTML 标签：：

![image-20241001124249313](./assets/image-20241001124249313.png)



![image-20241001124258029](./assets/image-20241001124258029.png)





###### 5.1.1 用令牌 CSRF 保证表单的安全



HTML表单想要在Django中正常显示，还需要添加CSRF令牌。CSRF令牌是Django为了防止网站跨站请求伪造而默认开启的一项保护机制。在Django中，通过“ `{%csrf_token%)` ” 标签为 表单添加令牌。



![image-20241001124433127](./assets/image-20241001124433127.png)



默认就有这个中间件



###### 5.1.2 【实战】用 HTML 表单上传文件



新应用 app5



![image-20241001124536085](./assets/image-20241001124536085.png)



模板

![image-20241001124615729](./assets/image-20241001124615729.png)



视图

![image-20241001124732587](./assets/image-20241001124732587.png)



路由



![image-20241001125038828](./assets/image-20241001125038828.png)



![image-20241001124841761](./assets/image-20241001124841761.png)



试试



![image-20241001125111798](./assets/image-20241001125111798.png)



![image-20241001125215382](./assets/image-20241001125215382.png)



看看文件夹



![image-20241001125229183](./assets/image-20241001125229183.png)



没问题



##### 5.2 Django 的 Form 表单



Django框架提供了Form表单，用于生成页面可用的HTML标签。用户在表单中输入数据提交表单时，Django框架会自动进行表单数据验证，并将数据绑定到表单对象。



###### 5.2.1 认识 Form 表单



新建实例

![image-20241001125450595](./assets/image-20241001125450595.png)



1. 表单字段





![image-20241001125510469](./assets/image-20241001125510469.png)



（1）选择类型字段 ChoiceField

（2）时间日期类型字段

（3）选择类型字段





2. 常用字段参数



![image-20241001125607298](./assets/image-20241001125607298.png)





3. 表单元素的风格显示



参数widget的作用是，按照widget指定的类型在网页中生成对应的标签样式。



![image-20241001125705335](./assets/image-20241001125705335.png)





4. 表单的综合实例



（1）新建表单文件



![image-20241001125811538](./assets/image-20241001125811538.png)



（2）视图

![image-20241001125847813](./assets/image-20241001125847813.png)



（3）模板

![image-20241001125906099](./assets/image-20241001125906099.png)



（4）路由

![image-20241001125958124](./assets/image-20241001125958124.png)



效果

![image-20241001130034148](./assets/image-20241001130034148.png)



没问题



###### 5.2.2 表单数据的校验



Django的表单提供了强大的数据校验功能。



![image-20241001135754955](./assets/image-20241001135754955.png)



1. 校验数据





（1）表单类

![image-20241001135908679](./assets/image-20241001135908679.png)



每个字段，添加 error_messages 参数





（2）视图函数



![image-20241001140111827](./assets/image-20241001140111827.png)



（3）模板

![image-20241001140041457](./assets/image-20241001140041457.png)



（4）路由



![image-20241001140156819](./assets/image-20241001140156819.png)

效果

提交

![image-20241001140341776](./assets/image-20241001140341776.png)



2. 自定义验证规则



![image-20241001140413343](./assets/image-20241001140413343.png)



就是这些 了



![image-20241001140444724](./assets/image-20241001140444724.png)





###### 5.2.3 表单数据的获取



在表单验证成功后，可以通过forms.clean 方法或者forms.cleaned_data属性获取表单提交的数据。此外，还可以通过forms.data属性获取表单原始的数据。



![image-20241001140602185](./assets/image-20241001140602185.png)



试试

![image-20241001140728683](./assets/image-20241001140728683.png)



数据拿到了，就可以 ORM 入库了



###### 5.2.4 【实战】用 Form 表单上传文件



模板

![image-20241001140827812](./assets/image-20241001140827812.png)



模型类



![image-20241001140911034](./assets/image-20241001140911034.png)



迁移一下

![image-20241001140952983](./assets/image-20241001140952983.png)



OK，表单类



![image-20241001141016344](./assets/image-20241001141016344.png)



视图



![image-20241001141052313](./assets/image-20241001141052313.png)



路由



![image-20241001141158825](./assets/image-20241001141158825.png)



![image-20241001141224152](./assets/image-20241001141224152.png)



试试



![image-20241001141332474](./assets/image-20241001141332474.png)



![image-20241001141343888](./assets/image-20241001141343888.png)



数据表



![image-20241001141358544](./assets/image-20241001141358544.png)



没问题



##### 5.3 Django 的模型表单



Django提供了模型表单(ModelForm),它可以和模型直接关联，省略了在Form表单中定义表单字段的过程。



###### 5.3.1 认识模型表单



表单类

![image-20241001141638842](./assets/image-20241001141638842.png)



测试一下

视图

![image-20241001141754886](./assets/image-20241001141754886.png)



路由



![image-20241001141829318](./assets/image-20241001141829318.png)



效果



![image-20241001141909758](./assets/image-20241001141909758.png)



没问题，效果和之前一样



常见的模型表单属性：

![image-20241001141940658](./assets/image-20241001141940658.png)



![image-20241001141947566](./assets/image-20241001141947566.png)





###### 5.3.2 校验模型表单数据



1. 校验数据





![image-20241001142047820](./assets/image-20241001142047820.png)



效果

![image-20241001142138492](./assets/image-20241001142138492.png)



没问题



2. 自定义校验函数



![image-20241001142212680](./assets/image-20241001142212680.png)



![image-20241001142242030](./assets/image-20241001142242030.png)



没问题



![image-20241001142314159](./assets/image-20241001142314159.png)



全局函数 也能校验



###### 5.3.3 处理模型表单数据



Django的ModelForm类提供了save()方法，用于将表单绑定的数据直接保存到数据库中



![image-20241001142739250](./assets/image-20241001142739250.png)



（1）直接接收 post 请求提供的数据

![image-20241001142816270](./assets/image-20241001142816270.png)



试试



![image-20241001142913486](./assets/image-20241001142913486.png)



数据表



![image-20241001142926473](./assets/image-20241001142926473.png)



没问题



（2）可以直接调用表单类生成类实例，完成数据显示

（3）调用表单类生成类实例，完成数据修改



（4）save 接受一个 commit 参数，默认为 True， 可以实现 Model 示例的保存



![image-20241001143148967](./assets/image-20241001143148967.png)



效果

![image-20241001143211357](./assets/image-20241001143211357.png)



但是插进去的



![image-20241001143219779](./assets/image-20241001143219779.png)



没毛病，就是在保存之前可以进行一些处理





##### 5.4 使用 Ajax 提交表单



简单来说，AJAX就是在不重载整个网页的情况下，通过后台加载数据，并在网页上进行局部刷新和显示。





###### 5.4.1 基于 jQuery 技术实现 Ajax



使用jQuery技术来实现AJAX比较简单。jQuery提供多个与AJAX相关的方法。



一般写法：

![image-20241001143336956](./assets/image-20241001143336956.png)



![image-20241001143342351](./assets/image-20241001143342351.png)





###### 5.4.2 在 Ajax 请求中设置令牌 csrf_token



1. 在前台模板中解决

   ![image-20241001143526592](./assets/image-20241001143526592.png)

2. 在视图函数中解决

   在每个视图函数前都增加了@csrf_exempt装饰器来去掉CSRF校验。



###### 5.4.3 【实战】 使用 Ajax 实现用户登录



视图



![image-20241001143600267](./assets/image-20241001143600267.png)



模板

![image-20241001143629629](./assets/image-20241001143629629.png)



路由

![image-20241001143656836](./assets/image-20241001143656836.png)



效果



![image-20241001143801466](./assets/image-20241001143801466.png)



没问题





#### 第 6 章 用户认证



Django作为一款优秀的Web框架，自动内置了用户认证体系，功能强大，可以“开箱即用”。还可以在Django用户认证体系的基础上进行定制和扩展，以满足不同的业务需求。



##### 6.1 初识用户认证



- 用户：应用系统的使用者。用户拥有自己的权限，可以属于一个或者多个用户组。
- 用户组：对用户进行分类的一种便捷方法
- 权限：约束用户行为的一种机制





###### 6.1.1 认识 Auth 模块



Auth模块是Django框架内置的权限管理模块。利用Auth模块可以实现用户身份认证、用户组和权限管理。



![image-20241001144109370](./assets/image-20241001144109370.png)



在Auth模块中封装了用户模型、用户组模型和权限模型



![image-20241001144130254](./assets/image-20241001144130254.png)



用户模型字段：

![image-20241001144143111](./assets/image-20241001144143111.png)



Auth 模块相关方法：

![image-20241001144205549](./assets/image-20241001144205549.png)



###### 6.1.2 了解用户权限数据表



![image-20241001144244543](./assets/image-20241001144244543.png)



这六张表：

![image-20241001144257159](./assets/image-20241001144257159.png)





##### 6.2 用户管理



来吧， app6



![image-20241001144350178](./assets/image-20241001144350178.png)



###### 6.2.1 用户注册



视图

![image-20241001144459235](./assets/image-20241001144459235.png)



模板





路由

![image-20241001145552954](./assets/image-20241001145552954.png)





![image-20241001145927765](./assets/image-20241001145927765.png)



这都在视图里面写死了，但是数据确实插进去了



![image-20241001150011154](./assets/image-20241001150011154.png)





###### 6.2.2 用户登录



使用用户模型提供的强大用户认证Auth模块，可以很方便地实现登录功能



视图

![image-20241001150119283](./assets/image-20241001150119283.png)



模板

![image-20241001150156003](./assets/image-20241001150156003.png)



路由

![image-20241001150228418](./assets/image-20241001150228418.png)



效果



![image-20241001150357138](./assets/image-20241001150357138.png)



比较水



![image-20241001150618491](./assets/image-20241001150618491.png)



session 确实设置了



###### 6.2.3 扩展用户模型



Django框架提供了扩展用户模型的方法，一般使用继承AbstractUser类的方式来扩展用户模型。AbstractUser类不会改变现有验证方法的使用。



1. 修改数据模型



![image-20241001150701209](./assets/image-20241001150701209.png)



2. 配置项目文件



![image-20241001150809684](./assets/image-20241001150809684.png)



3. 数据迁移



![image-20241001151044236](./assets/image-20241001151044236.png)



先把 auth 和 django 开头的都删掉



![image-20241001151323708](./assets/image-20241001151323708.png)



迁移完成





4. 查看效果



![image-20241001151438797](./assets/image-20241001151438797.png)

![image-20241001151506353](./assets/image-20241001151506353.png)



##### 6.3 【实战】利用用户模型实现用户身份认证及状态保持



###### 6.3.1 增加注册视图函数



![image-20241001151723715](./assets/image-20241001151723715.png)



###### 6.3.2 增加登录视图函数



![image-20241001151831665](./assets/image-20241001151831665.png)



###### 6.3.3 用户退出视图函数



![image-20241001151902049](./assets/image-20241001151902049.png)



###### 6.3.4 用户首页的显示视图函数



![image-20241001151944934](./assets/image-20241001151944934.png)



模板

![image-20241001152011460](./assets/image-20241001152011460.png)



配置路由

![image-20241001152052166](./assets/image-20241001152052166.png)

效果



![image-20241001152241600](./assets/image-20241001152241600.png)



注册完成，进行登录



![image-20241001152330695](./assets/image-20241001152330695.png)



擦， session 表没了，要建出来



![image-20241001152726702](./assets/image-20241001152726702.png)



重新迁移一次就行了



再来登录一次看看



![image-20241001152936477](./assets/image-20241001152936477.png)



进来了

![image-20241001152949467](./assets/image-20241001152949467.png)



session 也插入了

退出

![image-20241001153023987](./assets/image-20241001153023987.png)



确实重定向到了登录页面，看看 session 表



![image-20241001153043992](./assets/image-20241001153043992.png)



也删了

但是现在有个问题，还是能访问首页



![image-20241001153133847](./assets/image-20241001153133847.png)



这样显然不合理，这就涉及权限问题了



##### 6.4 权限管理



###### 6.4.1 权限的设置



Django认证系统默认对一个数据模型设置4个权限：查看 view、增加 add 、修改 charge 、删除 delete 权限。

![image-20241001153337943](./assets/image-20241001153337943.png)



![image-20241001153320907](./assets/image-20241001153320907.png)



字段说明：

![image-20241001153352133](./assets/image-20241001153352133.png)





###### 6.4.2 权限认证的相关方法



Python中的装饰器是一种用于拓展原来函数功能的函数，其特殊之处是其返回值也是一个函数。使用Python装饰器的好处是，可以在不更改原函数代码的前提下给函数增加新功能。



常用的装饰器：

![image-20241001153438356](./assets/image-20241001153438356.png)



在用户通过身份认证后，可以通过下表的方法进行用户组和权限的增加、删除、修改和查询

![image-20241001153521429](./assets/image-20241001153521429.png)





###### 6.4.3 自定义用户权限



![image-20241001153607676](./assets/image-20241001153607676.png)



执行迁移



![image-20241001153646893](./assets/image-20241001153646893.png)



没问题，这是我们自定义的新增的权限



##### 6.5 【实战】用装饰器控制页面权限



###### 6.5.1 增加权限装饰器



![image-20241001153849991](./assets/image-20241001153849991.png)



###### 6.5.2 修改模板文件



![image-20241001154010512](./assets/image-20241001154010512.png)



###### 6.5.3 设置项目配置文件



![image-20241001154106219](./assets/image-20241001154106219.png)



###### 6.5.4 测试权限



登录 admin 后台



![image-20241001154412516](./assets/image-20241001154412516.png)



擦， 我的管理后台没有那个什么 创建用户



![image-20241001154541644](./assets/image-20241001154541644.png)



这样试试



![image-20241001154603795](./assets/image-20241001154603795.png)



这下有了，创建一个 test 用户



![image-20241001154707696](./assets/image-20241001154707696.png)



保存



![image-20241001154746344](./assets/image-20241001154746344.png)



试试

![image-20241001154823039](./assets/image-20241001154823039.png)



可以看见删除，单击修改



![image-20241001154957092](./assets/image-20241001154957092.png)



可以跳过来



如果用 test 登录，

![image-20241001155024287](./assets/image-20241001155024287.png)



![image-20241001155335412](./assets/image-20241001155335412.png)

看不见删除，而且点击修改的话



![image-20241001155404299](./assets/image-20241001155404299.png)



直接报错了，反正就是没有权限，访问不到



这就是简单的权限测试



##### 6.6 中间件技术



中间件实际上就是AOP（面向切面编程)。AOP的主要作用是，把一些跟核心业务逻辑模块无关的功能抽离出来。这些跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来之后，再通过“动态切入”的方式将这些功能融入业务逻辑模块中。



好处：

1. 可以保持业务逻辑模块的“纯净”和高内聚性，
2. 可以很方便地复用日志统计、安全控制等功能模块



###### 6.6.1 认识 Django 中间件



Django中间件是修改Django Request或者Response对象的钩子



![image-20241001160149914](./assets/image-20241001160149914.png)



Django 默认的中间件：

![image-20241001160344367](./assets/image-20241001160344367.png)



执行顺序：从上到下。





###### 6.6.2 使用 Django 中间件



5 个方法：

![image-20241001160420320](./assets/image-20241001160420320.png)



其中，process_request 和 process_response 方法用得较多。



【实例】

（1）创建

![image-20241001160612670](./assets/image-20241001160612670.png)



（2）配置

![image-20241001160652205](./assets/image-20241001160652205.png)



（3）视图和路由

![image-20241001160721231](./assets/image-20241001160721231.png)



![image-20241001161355415](./assets/image-20241001161355415.png)



效果



![image-20241001161459392](./assets/image-20241001161459392.png)



在 中间件1 直接返回试试



![image-20241001161542476](./assets/image-20241001161542476.png)



再试试



![image-20241001161642678](./assets/image-20241001161642678.png)

![image-20241001161730451](./assets/image-20241001161730451.png)



意思就是 在这儿直接返回的话，接下去就直接执行 process_response ，后面的中间件都不会执行了





###### 6.6.3 【实战】 用中间件简化权限认证



新建中间件文件

![image-20241001161947159](./assets/image-20241001161947159.png)

配置



![image-20241001162006837](./assets/image-20241001162006837.png)





测试



![image-20241001162120750](./assets/image-20241001162120750.png)



test 不在白名单，而且用户未登录，所以直接跳转到登录页面，这里记得给上面那个测试放行

这样也相当于用中间件技术简化了 权限认证过程。





### 第 2 篇 后台项目实战



#### 第 7 章 【实战】开发一个商城系统的后台



##### 7.1 商城系统后台的设计分析



###### 7.1.1 需求分析



功能图：

![image-20241001162429216](./assets/image-20241001162429216.png)



###### 7.1.2 架构设计



![image-20241001162449104](./assets/image-20241001162449104.png)



###### 7.1.3 数据库模型设计



- 逻辑模型设计
- 物理模型设计





1. 生成物理模型

   ![image-20241001162540029](./assets/image-20241001162540029.png)

   模型设计完成后，可以导出 DDL 脚本，然后指定数据库中生成数据表

2. 反向生成 Django 模型

   在完成数据库的物理模型设计后，可以根据物理模型反向生成Django模型。





##### 7.2 使用 Django 自带的 Admin 后台管理系统



Django自带的Admin后台管理系统可用于对网站中的各个模块进行管理



###### 7.2.1 创建商城系统后台项目



新项目：`myshop-back`



![image-20241001162807425](./assets/image-20241001162807425.png)



![image-20241001163501107](./assets/image-20241001163501107.png)



这里换成了用命令，不知道为什么那个不行



![image-20241001163648108](./assets/image-20241001163648108.png)



然后用 pycharm 打开了



![image-20241001163819579](./assets/image-20241001163819579.png)



创建四个应用



![image-20241001163843587](./assets/image-20241001163843587.png)



全部挪到 apps 下，配置文件



![image-20241001163942435](./assets/image-20241001163942435.png)



创建商品分类模型和商品模型



![image-20241001164512029](./assets/image-20241001164512029.png)



这里我直接把环境弄成一样的了，免得又有问题



goods 模型类：



![image-20241001164631017](./assets/image-20241001164631017.png)



users 模型类：

![image-20241001164848964](./assets/image-20241001164848964.png)



order 模型类：



![image-20241001164920906](./assets/image-20241001164920906.png)



basic 模型类：

![image-20241001165000719](./assets/image-20241001165000719.png)



OK， 直接迁移吧



不行，报错了，感觉很多包冲突了



![image-20241001165918183](./assets/image-20241001165918183.png)



我觉得重开一个虚拟环境

![image-20241001170844002](./assets/image-20241001170844002.png)



表迁移出来了

这里我打算用高一点 Django 版本， 4.2 的



![image-20241001171308308](./assets/image-20241001171308308.png)



###### 7.2.2 登录 Admin 后台管理系统



来吧，创建管理员



![image-20241001171432513](./assets/image-20241001171432513.png)





主要是打了日志，看着有点怪



![image-20241001171527231](./assets/image-20241001171527231.png)



没啥毛病，登录



![image-20241001171608416](./assets/image-20241001171608416.png)



又看不见用户



![image-20241001171731770](./assets/image-20241001171731770.png)



这里加上



![image-20241001171802293](./assets/image-20241001171802293.png)



问题不大，虽然有些地方看着有些奇怪



![image-20241001171920644](./assets/image-20241001171920644-1727774361148-4.png)



重新登录就正常了



###### 7.2.3 配置 Admin 后台管理系统



1. 设置 apps.py 文件
2. 设置 `__init__.py` 文件
3. 设置 admin.py 文件



![image-20241001172206935](./assets/image-20241001172206935.png)



![image-20241001172239563](./assets/image-20241001172239563.png)



![image-20241001172400483](./assets/image-20241001172400483.png)



效果



![image-20241001172434144](./assets/image-20241001172434144.png)



![image-20241001172503000](./assets/image-20241001172503000.png)



![image-20241001172514644](./assets/image-20241001172514644.png)



同理，把其他都加上



![image-20241001172748727](./assets/image-20241001172748727.png)



就可以得到这样一个后台



增加商品分类



![image-20241001173135118](./assets/image-20241001173135118.png)



![image-20241001173954720](./assets/image-20241001173954720.png)



富文本编辑器也没问题





##### 7.3 用 Bootstrap 框架实现商城系统后台



###### 7.3.1 开发用户注册模块



（1）模型类



![image-20241001174216322](./assets/image-20241001174216322.png)



这个昵称我就不放开了，不迁移了



（2）表单类



![image-20241001174309460](./assets/image-20241001174309460.png)



（3）视图函数

![image-20241001174339661](./assets/image-20241001174339661.png)



模板

![image-20241001174642422](./assets/image-20241001174642422.png)



配置路由，

![image-20241001174720756](./assets/image-20241001174720756.png)



效果

![image-20241001175231809](./assets/image-20241001175231809.png)



![image-20241001175238478](./assets/image-20241001175238478.png)



看下数据库



![image-20241001175307036](./assets/image-20241001175307036.png)



将就看吧，图片太大了，但是能用的



![image-20241001175404535](./assets/image-20241001175404535.png)



稍微改了一下，看着好多了



###### 7.3.2 开发用户登录模块



（1）视图函数



![image-20241001175454331](./assets/image-20241001175454331.png)



![image-20241001175506467](./assets/image-20241001175506467.png)



（2）模板文件



![image-20241001175603252](./assets/image-20241001175603252.png)



（3）路由

![image-20241001175627823](./assets/image-20241001175627823.png)



![image-20241001175727476](./assets/image-20241001175727476.png)



效果



![image-20241001175655106](./assets/image-20241001175655106.png)



![image-20241001175707426](./assets/image-20241001175707426.png)



###### 7.3.3 开发商城系统后台首页面



1. 认识 Bootstrap 框架



AdminLTE是基于Bootstrap框架开发的一套受欢迎的开源的后台管理模板。这里使用AdminLTE3.1.0版本作为商城系统后台的模板框架。



2. 构建母版页



![image-20241001180024172](./assets/image-20241001180024172.png)



这部分我就直接复制了



新建 `base.html`



![image-20241001180149258](./assets/image-20241001180149258.png)



3. 构建内容页



![image-20241001180235029](./assets/image-20241001180235029.png)



路由



![image-20241001180306006](./assets/image-20241001180306006.png)



效果



![image-20241001180342942](./assets/image-20241001180342942.png)



还行



###### 7.3.4 开发用户信息维护模块



1. 实现效果



2. 用户列表



（1）模型类

![image-20241001180513815](./assets/image-20241001180513815.png)



（2）模板



![image-20241001180602045](./assets/image-20241001180602045.png)



（3）视图函数

![image-20241001180751245](./assets/image-20241001180751245.png)



路由



![image-20241001180803726](./assets/image-20241001180803726.png)



效果



![image-20241001181200487](./assets/image-20241001181200487.png)



差不多，将就



3. 删除用户



![image-20241001181244369](./assets/image-20241001181244369.png)



视图函数



![image-20241001181333475](./assets/image-20241001181333475.png)



这里就不试了



4. 多条件查询





![image-20241001181428193](./assets/image-20241001181428193.png)



这里和分页那儿一块儿吧，都是改视图函数



5. 使用 Django 内置的分页功能完善会员列表



Paginator类的属性和方法：

![image-20241001181522322](./assets/image-20241001181522322.png)



Page 类常用的属性和方法：

![image-20241001181544021](./assets/image-20241001181544021.png)



![image-20241001181552651](./assets/image-20241001181552651.png)



来吧实现效果



![image-20241001181622446](./assets/image-20241001181622446.png)



效果



![image-20241001181653155](./assets/image-20241001181653155.png)



数据太少了，看不出来



![image-20241001181910907](./assets/image-20241001181910907.png)



又注册了一个用户，看看现在



![image-20241001181931131](./assets/image-20241001181931131.png)



第二页

![image-20241001182104789](./assets/image-20241001182104789.png)



这里有点小问题，必须选到分类才能切过去，不严谨，因为会拿到 None 值



###### 7.3.5 开发商品分类管理模块



1. 商品分类列表



（1）商品分类模型



![image-20241001183212440](./assets/image-20241001183212440.png)





（2）抽象类



![image-20241001183247604](./assets/image-20241001183247604.png)



（3）抽象类改写模型



2. 添加商品分类



（1）实现效果



（2）表单类

![image-20241001183420426](./assets/image-20241001183420426.png)



（3）视图类处理请求

![image-20241001183448425](./assets/image-20241001183448425.png)



（4）模板 + 路由

![image-20241001183532412](./assets/image-20241001183532412.png)



![image-20241001183549748](./assets/image-20241001183549748.png)



效果



![image-20241001183628644](./assets/image-20241001183628644.png)



试试



![image-20241001190525870](./assets/image-20241001190525870.png)



确实能加



然后就是分类的信息展示页面



![image-20241001190649616](./assets/image-20241001190649616.png)



视图函数

![image-20241001190709080](./assets/image-20241001190709080.png)



路由



![image-20241001190719033](./assets/image-20241001190719033.png)



效果



![image-20241001190730433](./assets/image-20241001190730433.png)



还行



###### 7.3.6 开发商品信息管理模块



1. 使用 Bootstrap-table 插件完成商品列表



（1）实现效果

（2）创建模板文件

![image-20241001190932868](./assets/image-20241001190932868.png)



（3）视图函数

![image-20241001191038313](./assets/image-20241001191038313.png)



![image-20241001191127046](./assets/image-20241001191127046.png)



路由

![image-20241001191146887](./assets/image-20241001191146887.png)



效果



![image-20241001191220979](./assets/image-20241001191220979.png)



当然现在还没有商品



2. 使用富文本编辑器美化商品描述信息



（1）实现效果

（2）安装富文本编辑器



![image-20241001191337505](./assets/image-20241001191337505.png)



（3）配置文件

![image-20241001191411223](./assets/image-20241001191411223.png)



![image-20241001191422669](./assets/image-20241001191422669.png)





（4）配置路由

![image-20241001191444263](./assets/image-20241001191444263.png)



（5）修改商品数据模型

![image-20241001191511947](./assets/image-20241001191511947.png)



（6）复制资源文件

![image-20241001191541200](./assets/image-20241001191541200.png)



（7）完善商品模板文件

![image-20241001191646843](./assets/image-20241001191646843.png)



效果



![image-20241001191703897](./assets/image-20241001191703897.png)



试试



![image-20241001192723557](./assets/image-20241001192723557.png)



就这样吧，这个做得挺随便的

![image-20241001193007009](./assets/image-20241001193007009.png)



代码里面没写保存，我说怎么存不进去



![image-20241001193053385](./assets/image-20241001193053385.png)



试试，算了，很多需要的数据，前端并没有写，所以存不进去



### 第 3 篇 进阶



#### 第 8 章 接口的设计与实现



来咯，DRF 框架高效实现接口



##### 8.1 前后端分离



###### 8.1.1 了解前后端分离



1. 前后端不分离



![image-20241001193523150](./assets/image-20241001193523150.png)



前端 HTML 代码中混杂后端的模板语法，后端控制前端的渲染展示，耦合度极高。



2. 前后端分离



![image-20241001193540183](./assets/image-20241001193540183.png)



前后端通过接口实现完全解耦，各干各的事情。它们的唯一联系纽带就是事先规划好的接口。



###### 8.1.2 为什么要前后端分离



1. 前后端不分离的痛点



（1）前后端开发职责不清晰

（2）开发效率低下



2. 前后端分离带来的问题



（1）技术门槛增加，学习曲线加大

（2）约定文档必须详细

（3）增加项目成本





###### 8.1.3 如何实施前后端分离



1. 职责分离

2. 开发流程





###### 8.1.4 前后端分离的技术栈



![image-20241001193924148](./assets/image-20241001193924148.png)





##### 8.2 设计符合标准的 RESTful 接口



1. 域名

   API的域名应该具有一定的辨识度

2. 协议

   应采用HTTPS协议确保数据安全。这只是建议，实际上很多时候都在使用HTTP协议

3. 版本

   建议把版本号放入API路径中，一目了然，

4. 路径

   API请求路径中只能含有名词，不应该含有动词。

5. HTTP 请求动词

   ![image-20241001194119117](./assets/image-20241001194119117.png)

   例子：

   ![image-20241001194127981](./assets/image-20241001194127981.png)



6. 过滤分页参数

   AP|应该提供查询过滤参数，分页参数并返回结果。

   ![image-20241001194155763](./assets/image-20241001194155763.png)

7. 状态码

   ![image-20241001194205128](./assets/image-20241001194205128.png)

8. 返回消息格式

   例子：

   ![image-20241001194220085](./assets/image-20241001194220085.png)





##### 8.3 序列化和反序列化



###### 8.3.1 认识序列化和反序列化



- 对象从内存中变成可存储或可传输的过程，被称为“序列化”
- 对象从文件中的数据恢复到内存中的过程，被称为“反序列化”。



新应用 app8

![image-20241001205319068](./assets/image-20241001205319068.png)





###### 8.3.2 用 JSON 模块进行数据交互



JSON模块中的dumps 方法用于将Python对象序列化为JSON字符串

模型类

![image-20241001205522418](./assets/image-20241001205522418.png)



迁移

![image-20241001205639013](./assets/image-20241001205639013.png)



添加一些数据

![image-20241001205816323](./assets/image-20241001205816323.png)



（1）视图类



![image-20241001205928585](./assets/image-20241001205928585.png)



（2）路由



![image-20241001210027797](./assets/image-20241001210027797.png)



效果



![image-20241001210216586](./assets/image-20241001210216586.png)



没问题



###### 8.3.3 用 JsonResponse 类进行数据交互



JsonResponse类是HttpResponse的子类，用来输出JSON格式的数据。

视图类：

![image-20241001210504667](./assets/image-20241001210504667.png)



路由不变，效果



![image-20241001210535529](./assets/image-20241001210535529.png)



效果不变，

但是这两种方式都有一些问题：

1. 每个字段需要输入
2. Decimal 类型字段不能直接序列化
3. ImgFile 类型不能直接序列化
4. 接口格式不友好
5. ...





##### 8.4 接口开发 —— 基于 Django Rest Framework 框架



Django Rest Framework是一个基于Django并遵循RESTful接口规范的框架，简称DRF



###### 8.4.1 安装 DRF 框架



DRF框架可以在Django的基础上迅速开发接口。



`pip install djangorestframework==3.12.4`



配置：

![image-20241001210828692](./assets/image-20241001210828692.png)



###### 8.4.2 用 Serializer 类和 ModelSerializer 类进行序列化操作



1. 用 Serializer 类进行序列化



（1）模型类

商品分类和商品模型



![image-20241001211005404](./assets/image-20241001211005404.png)



![image-20241001211022017](./assets/image-20241001211022017.png)



（2）创建序列化文件

![image-20241001211141578](./assets/image-20241001211141578.png)



序列化类提供了丰富的字段，一些通用参数：



![image-20241001211206954](./assets/image-20241001211206954.png)



（3）创建视图类



![image-20241001211302136](./assets/image-20241001211302136.png)



（4）路由

![image-20241001211337757](./assets/image-20241001211337757.png)



效果

![image-20241001211412542](./assets/image-20241001211412542.png)



当前登录用户是 test 哈哈，这个 session 它还记着呢



2. 用 ModelSerializer 类进行序列化



（1）创建序列化类



![image-20241001211553603](./assets/image-20241001211553603.png)



（2）修改视图类

![image-20241001211708708](./assets/image-20241001211708708.png)



效果

![image-20241001211729219](./assets/image-20241001211729219.png)



当然这里就是所有字段都序列化了



3. 序列化的嵌套



在商品模型中关联着商品分类模型，所以，在商品模型对外提供接口中，需要一次性提供商品数据及其关联的商品分类数据。这就是一个典型的序列化的嵌套问题。



（1）用 Serializer 类进行序列化嵌套



![image-20241001211902344](./assets/image-20241001211902344.png)



![image-20241001211939806](./assets/image-20241001211939806.png)



直接访问

![image-20241001212053457](./assets/image-20241001212053457.png)



（2）用 ModelSerializer 类进行序列化嵌套



![image-20241001212212517](./assets/image-20241001212212517.png)



效果



![image-20241001212246288](./assets/image-20241001212246288.png)



没问题，嵌套成功



###### 8.4.3 请求和响应



DRF框架中的Request类，扩展了Django中标准的HttpRequest类。

DRF框架中的Response类是Django中SimpleTemplateResponse类的一个子类，与Django中的HttpResponse类很相似。Response类主要用来给前端返回数据



状态码：



![image-20241001212349146](./assets/image-20241001212349146.png)



###### 8.4.4 【实战】用装饰器 @api-view 实现视图函数



1. 什么是 DRF 框架中的视图函数



DRF框架允许使用视图函数，它提供一个简单的包装器来包装视图函数，以确保视图函数可以接收Request实例（不是Django中的HttpRequest实例），并允许视图函数返回Response实例



2. 装饰器 @api-view 的原理



视图函数的核心是api_view装饰器，它接受参数为视图响应的HTTP的方法列表。



3. 用装饰器 @api_view 创建一个 RESTful 接口



（1）修改序列化类

![image-20241001212617822](./assets/image-20241001212617822.png)



其中 create 方法对应 post 请求，为新增数据。update 对应 put 请求，对应修改数据。



（2）创建视图函数

![image-20241001212801839](./assets/image-20241001212801839.png)



（3）路由

![image-20241001212849015](./assets/image-20241001212849015.png)



效果

![image-20241001212953206](./assets/image-20241001212953206.png)



![image-20241001213015887](./assets/image-20241001213015887.png)



![image-20241001213223339](./assets/image-20241001213223339.png)



![image-20241001213245961](./assets/image-20241001213245961.png)



新增和更新都 没问题



###### 8.4.5 【实战】用 APIView 类实现视图类



DRF框架还提供了基于视图类的处理方式。



1. 什么是视图类



DRF框架中的视图类可以更好地处理不同的HTTP请求。可以采用面向对象的思维，把每个方法的处理逻辑变成类中的一个单独的方法，这样可以使程序逻辑变得简单、清晰。

在视图类中逻辑处理时，不用通过if…elif…的代码来判断是GET请求还是POST请求，而是利用在视图类中定义的get方法和post方法在各自的方法体内编写逻辑来判断。



2. APIView 类的原理



DRF框架提供了一个APIView类，该类是Django中View类的子类。

就是请求和返回响应不是一种实例罢了。



3. 用 APIView 类创建一个 RESTful 接口



（1）创建视图函数



![image-20241001213616281](./assets/image-20241001213616281.png)



（2）路由

![image-20241001213644085](./assets/image-20241001213644085.png)



效果和之前一样的



![image-20241001213710363](./assets/image-20241001213710363.png)



基于APIView类可以很好地完成接口开发，能够体现出DRF框架的特点，但是还不能体现DRF框架的优势，我们继续学习。



###### 8.4.6 【实战】用 Mixins 类改进 RESTful 接口



使用@api_view装饰器和APIView类开发接口，只能被称为传统方式，在DRF框架中这只是入门。



1. 什么是 Mixin 类



根据Python的多重继承特性，子类只需要继承不同功能的Mixin类，即可自动拥有Mixin类的各项功能。

举个例子：



![image-20241001213949836](./assets/image-20241001213949836.png)



2. DRF 框架中 Mixin 类的底层原理



DRF框架包含5类 Mixin



![image-20241001214033141](./assets/image-20241001214033141.png)





3. 用 Mixin 类创建一个 RESTful 接口



（1）新建文件



![image-20241001214155293](./assets/image-20241001214155293.png)



其中：GoodsView视图类用来完成对Goods表进行数据查询及数据新增。GoodsDetailView视图类用来完成对Goods表中单条数据的查询、修改和删除。



（2）路由

![image-20241001214256311](./assets/image-20241001214256311.png)



效果



![image-20241001214312945](./assets/image-20241001214312945.png)



![image-20241001214446689](./assets/image-20241001214446689.png)





效果不变，甚至更清晰了



![image-20241001214506642](./assets/image-20241001214506642.png)



不用自己写 json  了

![image-20241001214529659](./assets/image-20241001214529659.png)



###### 8.4.7 【实战】用 GenericAPIView 类实现视图类



将Mixin类和GenericAPIView类混配，已经大大减少了代码。



![image-20241001214633661](./assets/image-20241001214633661.png)



但是，DRF框架提供了一套将Mixin类与GenericAPIView类已经组合好的视图类，它“开箱即用”，可以进一步简化我们的代码。





1. 什么是 GenericAPIView 类



GenericAPIView类继承自APIView类，完全兼容APIView,它在APIView类的基础上增加了操作序列化器和数据库查询的方法，作用是为Mixin扩展类提供方法支持。



2. GenericAPIView 类的原理



（1）GenericAPIView 类的属性和方法

![image-20241001214809739](./assets/image-20241001214809739.png)

![image-20241001214818863](./assets/image-20241001214818863.png)





（2）分析 GenericAPIView 类

查看 `generics.py` 源文件，可以发现有一些继承GenericAPIView类的子类

这就是“继承类+Mixins类”混合使用的好处，代码越来越少，完美地体现了Django的优雅





3. 使用通用的 GenericAPIView 类创建一个 RESTful 接口



（1）视图类

![image-20241001215002562](./assets/image-20241001215002562.png)



（2）路由

![image-20241001215027945](./assets/image-20241001215027945.png)



效果

![image-20241001215049450](./assets/image-20241001215049450.png)



![image-20241001215101321](./assets/image-20241001215101321.png)



没毛病，效果不变，简化再简化



###### 8.4.8 用视图集 ViewSets 改进 RESTful 接口



从Mixins类到GenericAPIView类，代码在进一步减少，两行代码基本就可以了。但这还没到极致。



1. 什么是视图集 ViewSets



在DRF框架中，允许在一个类中组合一组相关视图的逻辑，这被称ViewSets。

ViewSets和APIView的不同：ViewSets不提供get、post()方法，而提供list()、create()方法；ViewSets对路由配置做了简化。



2. ViewSets 的底层原理



ViewSets继承自ViewSetMixin类。在ViewSetMixin中重写了as_view()方法，可以更方便地绑定动作行为actions。



相关主要类：

（1）GenericViewSet 类

（2）ModelViewSet 类

（3）ReadOnlyModelViewSet 类



3. 路由配置



（1）使用默认路由

视图类

![image-20241001215547961](./assets/image-20241001215547961.png)



路由

![image-20241001215635286](./assets/image-20241001215635286.png)



效果，也可以直接写在一行

![image-20241001215713090](./assets/image-20241001215713090.png)



效果

![image-20241001215801173](./assets/image-20241001215801173.png)



![image-20241001215808831](./assets/image-20241001215808831.png)





（2）使用 DefaultRouter 类

如果使用默认路由，则代码量较多，可以使用DefaultRouter类自动生成路由。



![image-20241001215950602](./assets/image-20241001215950602.png)



看看效果



![image-20241001220020298](./assets/image-20241001220020298.png)



没问题



4. 实例：使用 ModelViewSets 创建一个 RESTful 接口



![image-20241001220244267](./assets/image-20241001220244267.png)



路由



![image-20241001220303635](./assets/image-20241001220303635.png)



效果

![image-20241001220332179](./assets/image-20241001220332179.png)



没问题



![image-20241001220424303](./assets/image-20241001220424303.png)



这都是 router 对象生成的



![image-20241001220527090](./assets/image-20241001220527090.png)



###### 8.4.9 分页



在DRF框架中有多种分页方式。这里介绍普通分页。普通分页是指，将要显示的内容分为 n 页，每一页显示m条数据。



（1）新建分页类

![image-20241001220711789](./assets/image-20241001220711789.png)



（2）改造视图类

![image-20241001220851605](./assets/image-20241001220851605.png)



效果



![image-20241001221225253](./assets/image-20241001221225253.png)



（3）全局配置分页选项



![image-20241001221322800](./assets/image-20241001221322800.png)



![image-20241001221407203](./assets/image-20241001221407203.png)



效果



![image-20241001221439976](./assets/image-20241001221439976.png)



没毛病



在增加了全局配置分页选项后，在每一个视图类中就不需要再设置pagination_class类了。



###### 8.4.10 过滤、搜索与排序



在实际项目开发中，过滤、搜索和排序功能使用得非常多，DRF框架提供了强大的功能支持。



1. 过滤



安装配置

![image-20241001221639563](./assets/image-20241001221639563.png)



该指定一下版本的 ...

改回去了，用的 2.4.0 版本

![image-20241001222049028](./assets/image-20241001222049028.png)



差不多

配置

![image-20241001222253237](./assets/image-20241001222253237.png)



应用

![image-20241001222326120](./assets/image-20241001222326120.png)



（2）修改视图类

![image-20241001222448292](./assets/image-20241001222448292.png)



效果

![image-20241001222556017](./assets/image-20241001222556017.png)



![image-20241001222620697](./assets/image-20241001222620697.png)



可以发现，字段过滤只能进行完全匹配，无法进行模糊和区间匹配。



（3）创建自定义过滤器



![image-20241001222716532](./assets/image-20241001222716532.png)



常见的过滤器字段：



![image-20241001222730548](./assets/image-20241001222730548.png)



（4）修改视图类

![image-20241001222849728](./assets/image-20241001222849728.png)



效果



![image-20241001222934175](./assets/image-20241001222934175.png)



![image-20241001223014761](./assets/image-20241001223014761.png)



可以的



2. 搜索



![image-20241001223137513](./assets/image-20241001223137513.png)



效果



![image-20241001223204716](./assets/image-20241001223204716.png)





![image-20241001223227801](./assets/image-20241001223227801.png)



妙啊





3. 排序



![image-20241001223614584](./assets/image-20241001223614584.png)



按照 id 升序



![image-20241001223718424](./assets/image-20241001223718424.png)



按照价格降序



![image-20241001223747261](./assets/image-20241001223747261.png)



我把分页大小稍微改了，效果好些



###### 8.4.11 自定义消息格式



约定消息返回格式如下：



![image-20241001223926177](./assets/image-20241001223926177.png)



1. 继承rest_framework.response的Response类



![image-20241001224014060](./assets/image-20241001224014060.png)





2. 改造 ModelViewSet 视图集



（1）梳理 ModelViewSet 视图集



![image-20241001224145764](./assets/image-20241001224145764.png)





（2）自定义 ModelViewSet 类



![image-20241001224235719](./assets/image-20241001224235719.png)



3. 测试自定义消息



![image-20241001225615783](./assets/image-20241001225615783.png)



路由



![image-20241001224506800](./assets/image-20241001224506800.png)



效果



![image-20241001225520138](./assets/image-20241001225520138.png)





4. 改造分页类



这里有个问题，如果我们加上现在自己分页



![image-20241001225728755](./assets/image-20241001225728755.png)



格式就回去了，这是因为如果分页，因为GoodsView_Custom类继承自CustomModelViewSet类，则调用get_paginated_response()方法返回消息。因此，还要对这个方法进行处理。





![image-20241001225845991](./assets/image-20241001225845991.png)



再试一次



![image-20241001225934686](./assets/image-20241001225934686.png)



没毛病



###### 8.4.12 自定义异常格式



DRF框架的错误信息提示大致如下：就一个 detail

规定一个格式：

![image-20241001230027574](./assets/image-20241001230027574.png)



1. 创建自定义异常类



![image-20241001230104091](./assets/image-20241001230104091.png)



2. 全局配置



![image-20241001230153675](./assets/image-20241001230153675.png)



3. 测试执行



随便访问一个不存在的地址



![image-20241001230249199](./assets/image-20241001230249199.png)



没毛病，如果是之前



![image-20241001230310293](./assets/image-20241001230310293.png)



可以的





##### 8.5 接口安全机制



DRF 提供的认证方案：



- BasicAuthentication:基本的用户密码认证。
- SessionAuthentication:Session会话认证。比如，Diango的Admin后台管理系统就使用的这种认证方式。
- TokenAuthentication:使用Token令牌的HTTP身份认证。Token认证适用于前后端分离的项目。





###### 8.5.1 基于 DRF 框架实现 Token 认证



1. 配置应用





![image-20241002113537002](./assets/image-20241002113537002.png)



![image-20241002113604479](./assets/image-20241002113604479.png)



数据库迁移



![image-20241002113657485](./assets/image-20241002113657485.png)



这张表用于保存应用生成的用户 Token



2. 配置路由并获取 Token



![image-20241002113822026](./assets/image-20241002113822026.png)



访问接口文档：（这里又少写了，接口文档需要配置才有）

![image-20241002114116395](./assets/image-20241002114116395.png)



再试试



![image-20241002114253592](./assets/image-20241002114253592.png)



还有这儿试试，这里可能会出现版本问题【换成了 3.11】还要装一个 coreapi 应该



![image-20241002120932658](./assets/image-20241002120932658.png)



看看数据表



![image-20241002120953446](./assets/image-20241002120953446.png)



确实生成了，key 就是 token ，在每个用户登录应用后就会生成一个Token,而且是永久不变的。



3. 使用 Token



修改视图类

![image-20241002121401841](./assets/image-20241002121401841.png)



再试试访问 goods5 接口

![image-20241002121408910](./assets/image-20241002121408910.png)



![image-20241002121954788](./assets/image-20241002121954788.png)



直接访问是认证未通过，或者我们把自定义异常也关了



![image-20241002122032414](./assets/image-20241002122032414.png)



这就是提示需要权限，给他



![image-20241002122243575](./assets/image-20241002122243575.png)



马德，这写的我名字必须是 admin



![image-20241002122305726](./assets/image-20241002122305726.png)



直接改库，再看看



![image-20241002122322689](./assets/image-20241002122322689.png)



没问题，这下出来了



###### 8.5.2 基于 DRF 框架实现 JWT 认证



在前后端分离项目中，更多是使用JWT认证。



1. 认识 JWT



JWT(Json Web Token)是一种为了在网络应用环境间传递声明而执行的、基于JSON的开放标准。它由头部(Header)、负载(Payload)、签名(Signature)这3部分构成



3 段构成，用 `.` 连接



2. 使用 JWT —— 基于 djangorestframework-jwt 库



（1）安装

![image-20241002122534985](./assets/image-20241002122534985.png)



（2）配置应用

![image-20241002122838000](./assets/image-20241002122838000.png)



（3）配置路由

![image-20241002122907425](./assets/image-20241002122907425.png)



效果：

![image-20241002123008849](./assets/image-20241002123008849.png)



输入用户名密码，post



![image-20241002123041323](./assets/image-20241002123041323.png)



确实返回了一个 三段



3. 自定义返回认证信息



现在的默认返回信息中只有 token，可以自定义

![image-20241002123158756](./assets/image-20241002123158756.png)



配置

![image-20241002123216420](./assets/image-20241002123216420.png)



现在的效果

![image-20241002123238406](./assets/image-20241002123238406.png)



没问题。

客户端在收到服务器返回的JWT信息后，会将其存储在Cookie或localStorage中。当客户端与服务器再次交互时，会将JWT信息放入HTTP请求的Header Authorization字段中进行发送。



4. 权限认证



有些接口不需要登录验证，可以直接访问，比如商品列表、商品明细接口；而有些接口则必须通过登录验证，而且只能是自己操作自己的数据，比如用户信息修改接口等。



DRF 框架内置的权限组件的配置信息：

![image-20241002123345818](./assets/image-20241002123345818.png)





（1）全局配置

让访问所有的接口都需要登录验证

![image-20241002123447451](./assets/image-20241002123447451.png)



看看效果

![image-20241002123531960](./assets/image-20241002123531960.png)



没毛病



（2）局部配置

在指定的视图类中，通过 permission_classes 属性配置



![image-20241002123634838](./assets/image-20241002123634838.png)



这之前就试过了 ...

效果：我先把全局的注了



![image-20241002123753250](./assets/image-20241002123753250.png)



其他接口正常访问

![image-20241002123806662](./assets/image-20241002123806662.png)



这个接口需要登录



5. 自定义权限



试试

![image-20241002123938919](./assets/image-20241002123938919.png)



擦，这书就是，在最后的代码基础上写的， 这个之前都用过 了



![image-20241002124053908](./assets/image-20241002124053908.png)



哈哈，其实这个也一直在用，效果

![image-20241002124205418](./assets/image-20241002124205418.png)



在需要自定义权限校验的视图类中应用上就行，意思就是他会去判断 当前 JWT 解析 Token 生成的用户信息是否和 Goods 中的 user 字段一样，如果不一样就禁止访问【这里又顺序不好，还没讲 JWT 怎么用，】



6. 使用 JWT



![image-20241002124448503](./assets/image-20241002124448503.png)



加上 JWT



![image-20241002124547571](./assets/image-20241002124547571.png)



这样就拿到了，给其他视图类加上也是一样的效果



![image-20241002124953909](./assets/image-20241002124953909.png)



![image-20241002124856174](./assets/image-20241002124856174.png)



没毛病



7. Token 认证 和 JWT 认证的区别



Token认证将用户名和密码发送到服务端，由服务端进行校验，校验成功后会生成Token,将该Token保存到数据库中，并把该Token发送给客户端。客户端保存自己的Token,当客户端再次发起请求时，需要在HTTP协议的请求头中带上Token。服务端收到客户端请求的Token后，会将其和自己保存的Token做对比校验。



Tokn认证依靠数据库进行存储和查询，因此在大用户、高并发情况下性能较差。

JWT验证客户端发来的Token,不用进行数据库的查询，直接在服务端使用密钥进行校验。



JWT本身包含了认证信息，因此，一旦信息泄露，则任何人都可以获得令牌的所有权限。为了提高JWT的安全性，不宜将JWT的有限期设置得过长。对于重要的操作，应该每次都进行身份认证。为了提高JWT的安全性，不建议使用HTTP协议，而是使用安全性更高的HTTPS协议。



JWT最大的缺点：服务器只负责签发JWT,不负责保存。一旦JWT签发，则在有效期内它一直有效，无法中途废弃。因此 **JWT是一次性的**，要修改其中的信息，则必须重新签发一个新的JWT。



###### 8.5.3 基于后端技术的跨域解决方案



在浏览器中，只要发送请求的URL的协议、域名、端口号这三者中的任意一者与当前页面地址不同，则称之为跨域。



1. 浏览器的同源策略



同源策略（Same Origin Policy)是一种安全约定，是所有主流浏览器最核心，也是最基本的安全功能之一。



如果采用前后端分离方式开发，则由于前后端应用基本上不会使用同一个协议、域名和端口，所以，浏览器的同源策略会导致在前端应用访问后端接口时出现跨域错误。



> 不可避免



2. Django 中的跨域解决方法



（1）安装

`django-cors-headers==3.6.0`



![image-20241002141436485](./assets/image-20241002141436485.png)



（2）配置

![image-20241002141512932](./assets/image-20241002141512932.png)



![image-20241002141533728](./assets/image-20241002141533728.png)



加在中间件第一个



![image-20241002141554546](./assets/image-20241002141554546.png)



![image-20241002141703464](./assets/image-20241002141703464.png)



此外还可以配置白名单，以及哪些方法可以访问等信息，这样，从前端访问后端，就不会有跨域提示了。



##### 8.6 【实战】实现商城系统的接口



新项目：

![image-20241002142115150](./assets/image-20241002142115150.png)



###### 8.6.1 用户相关接口



1. 获取 Token 接口



这里用的就是 JWT 了，和之前一样，再做一遍



![image-20241002144825198](./assets/image-20241002144825198.png)



能到这个效果就



2. 用户注册接口



（1）用户注册的序列化处理



![image-20241002145010920](./assets/image-20241002145010920.png)



用户注册序列化类，如上



（2）新建视图类

![image-20241002145212345](./assets/image-20241002145212345.png)



（3）配置路由



![image-20241002145324420](./assets/image-20241002145324420.png)



效果

![image-20241002145928001](./assets/image-20241002145928001.png)



没啥问题



3. 用户登录接口



![image-20241002150017597](./assets/image-20241002150017597.png)



之前做这个只能通过 username 登录，加一个可以用手机号，那就要自定义验证类



（1）增加自定义验证类



![image-20241002150209808](./assets/image-20241002150209808.png)



（2）设置全局配置文件



![image-20241002150324861](./assets/image-20241002150324861.png)



（3）效果



![image-20241002150347921](./assets/image-20241002150347921.png)



用用户名可以

![image-20241002150427651](./assets/image-20241002150427651.png)

![image-20241002150435947](./assets/image-20241002150435947.png)



一样可以



4. 用户信息查询、修改和删除接口



（1）创建用户修改序列化类



![image-20241002150525401](./assets/image-20241002150525401.png)



（2）完善视图类

![image-20241002150619608](./assets/image-20241002150619608.png)



权限也是

![image-20241002150648135](./assets/image-20241002150648135.png)



根据不同的 action 请求进行权限验证



（3）配置路由并访问接口



![image-20241002150753534](./assets/image-20241002150753534.png)



效果，这里暂时把 JWT 认证关了，用了 session 认证，不然查不到



![image-20241002151558489](./assets/image-20241002151558489.png)



没毛病，随便修改一下



![image-20241002151820423](./assets/image-20241002151820423.png)



也能直接修改，没毛病

![image-20241002151928731](./assets/image-20241002151928731.png)



图片也正常上传了



###### 8.6.2 商品相关接口



1. 商品分类接口



（1）商品分类模型



![image-20241002152335973](./assets/image-20241002152335973.png)



（2）商品分类序列化

![image-20241002152453092](./assets/image-20241002152453092.png)



（3）商品分类视图



![image-20241002152618089](./assets/image-20241002152618089.png)



（4）路由



![image-20241002152716518](./assets/image-20241002152716518.png)



（5）效果



![image-20241002152823757](./assets/image-20241002152823757.png)



可以的，直接多级嵌套显示出来了

我的数据是这样的



![image-20241002152902045](./assets/image-20241002152902045.png)



2. 商品接口



（1）商品模型类



![image-20241002153143193](./assets/image-20241002153143193.png)



（2）增加商品序列化类

![image-20241002153303151](./assets/image-20241002153303151.png)



（3）商品视图类

![image-20241002153442708](./assets/image-20241002153442708.png)





Cache 那个还没讲，但是增加了 搜索、分页、过滤 和 排序的功能。

（4）路由

![image-20241002153608720](./assets/image-20241002153608720.png)



（5）效果

![image-20241002153717694](./assets/image-20241002153717694.png)



数据库只有这个商品，没事儿了



3. 商品轮播接口



（1）模型类



![image-20241002153820018](./assets/image-20241002153820018.png)





（2）序列化类

![image-20241002153834957](./assets/image-20241002153834957.png)



（3）视图类

![image-20241002153920195](./assets/image-20241002153920195.png)



（4）路由

![image-20241002153954273](./assets/image-20241002153954273.png)



（5）效果



![image-20241002154035230](./assets/image-20241002154035230.png)



没啥问题



![image-20241002154157112](./assets/image-20241002154157112.png)



加一个试试

![image-20241002154210759](./assets/image-20241002154210759.png)



没问题



![image-20241002154224036](./assets/image-20241002154224036.png)



4. 分类下的商品接口



（1）创建序列化类

在首页中一般会展示商品分类，每个分类下展示4~8个推荐商品



![image-20241002154343637](./assets/image-20241002154343637.png)



（2）创建视图类



![image-20241002154414888](./assets/image-20241002154414888.png)



（3）路由

![image-20241002154503293](./assets/image-20241002154503293.png)





（4）效果

![image-20241002154546649](./assets/image-20241002154546649.png)



其实这个我们在分类的时候就做了差不多的



###### 8.6.3 订单相关接口



订单相关接口主要包含“购物车”接口、“生成订单”接口、“查询我的订单”接口。



1. 购物车接口



（1）模型类



![image-20241002154737277](./assets/image-20241002154737277.png)



（2）序列化类



![image-20241002154824172](./assets/image-20241002154824172.png)



![image-20241002154934149](./assets/image-20241002154934149.png)



（3）视图类



![image-20241002155208607](./assets/image-20241002155208607.png)





（3）路由

![image-20241002155326146](./assets/image-20241002155326146.png)



效果，暂时不调试，这里是自己改了，改成 session 了，所以查出来了



![image-20241002155545590](./assets/image-20241002155545590.png)



随便加一个

![image-20241002155557061](./assets/image-20241002155557061.png)



没问题，关联起来了的



2. 生成订单接口

这个就比较复杂了，需要仔细考虑



视图类：

![image-20241002155814479](./assets/image-20241002155814479.png)



主要工作：

（1）生成订单编号

![image-20241002155851071](./assets/image-20241002155851071.png)



时间 + 用户 ID 生成的



（2）生成订单过程



（3）接口的幂等性设计

- 悲观锁

  ![image-20241002160225050](./assets/image-20241002160225050.png)

- 乐观锁



（4）事务处理

![image-20241002160001466](./assets/image-20241002160001466.png)



3. 查询我的订单接口



![image-20241002160050783](./assets/image-20241002160050783.png)



（2）路由

![image-20241002160119737](./assets/image-20241002160119737.png)



效果

![image-20241002160146147](./assets/image-20241002160146147.png)

###### 8.6.4 基础接口 —— 地址信息接口



1. 模型类



![image-20241002160332536](./assets/image-20241002160332536.png)



2. 序列化类



![image-20241002160357954](./assets/image-20241002160357954.png)



3. 地址信息接口的增加、删除、修改和查询



视图类

![image-20241002160451209](./assets/image-20241002160451209.png)



4. 路由配置及测试



![image-20241002160555305](./assets/image-20241002160555305.png)



效果



![image-20241002160635036](./assets/image-20241002160635036.png)



创建一个试试



![image-20241002160722066](./assets/image-20241002160722066.png)



没问题。



![image-20241002160819363](./assets/image-20241002160819363.png)



数据库也插进去了，关联的是当前登录的用户



##### 8.7 【实战】利用 DRF 生成接口文档



###### 8.7.1 安装依赖



![image-20241002120515033](./assets/image-20241002120515033.png)



###### 8.7.2 配置文件



![image-20241002120639359](./assets/image-20241002120639359.png)



![image-20241002120658247](./assets/image-20241002120658247.png)



这个应该放前面啊，顺序不是很好



###### 8.7.3 测试



![image-20241002120735406](./assets/image-20241002120735406.png)



这下有了【返回 `8.5.1`】



> 又到这里了，现在是 api 项目了



![image-20241002160923049](./assets/image-20241002160923049.png)



还行



![image-20241002161023607](./assets/image-20241002161023607.png)



能用





##### 8.8 【实战】利用 Swagger 服务让接口文档更专业





Swagger是一个用于生成、描述和调用RESTful接口的Web服务。通俗来讲，Swagger服务就是将项目中所有对外提供的接口展现在页面上，并且可以在线进行接口的调用和测试。



###### 8.8.1 安装配置 django-rest-swagger



`django-rest-swagger==2.2.0`



![image-20241002161149803](./assets/image-20241002161149803.png)



添加应用

![image-20241002161220369](./assets/image-20241002161220369.png)







###### 8.8.2 配置视图类



如果要对接口文档中的方法进行注释说明，则直接在该类下添加注释即可，如以下代码所示。



![image-20241002161351603](./assets/image-20241002161351603.png)



###### 8.8.3 配置路由



![image-20241002161538326](./assets/image-20241002161538326.png)



###### 8.8.4 运行效果



![image-20241002161729813](./assets/image-20241002161729813.png)



这里居然还要手动改一下



![image-20241002161839761](./assets/image-20241002161839761.png)



再试一次



![image-20241002161856771](./assets/image-20241002161856771.png)



6



![image-20241002161949680](./assets/image-20241002161949680.png)



没毛病，甚至能用



![image-20241002162025590](./assets/image-20241002162025590.png)





#### 第 9 章 分层的自动化测试



众所周知，自动化测试已经成为软件项目中不可或缺的测试方法，



##### 9.1 分层的自动化测试



分层的自动化测试分为单元自动化测试、接口自动化测试和用户界面自动化测试。



![image-20241002162222191](./assets/image-20241002162222191.png)



- 单元自动化测试：颗粒度最小，主要以类和方法为主，测试用例比较容易编写，在出现问题后容易快速定位问题。
- 接口自动化测试：颗粒度粗一些，以模块之间的数据交互为主，定位问题相对复杂。
- 用户界面自动化测试：主要在用户界面中进行，由于用户界面经常发生变化，导致测试脚本频繁改动，维护成本较高。



###### 9.1.1 单元自动化测试



Python → unitest 框架进行单元自动化测试



###### 9.1.2 接口自动化测试



接口测试的工作原理：接口测试工具模拟客户端向服务器发送报文请求；服务器接收请求并做出响应，然后向客户端返回应答信息；接口测试工具对响应消息进行解析。



测试过程中有两种方式：

- 利用Postman工具模拟客户端发起HTTP请求。
- 使用Python脚本直接编写程序模拟客户端发起HTTP请求。





###### 9.1.3 用户界面自动化测试



更有效的方法：编写用户界面测试用例，以自动化的方式执行用户操作。



##### 9.2 单元自动化测试



###### 9.2.1 认识单元测试框架 unitest



unittest 是Python自带的一个单元测试框架，无须安装，使用简单方便。



4 个重要概念：

（1）测试用例：测试用例是unittest中执行测试的最小单元。

![image-20241002162948122](./assets/image-20241002162948122.png)



（2）测试套件：测试套件是指一组测试用例，它将测试用例集合在一起。

（3）测试运行：测试运行是指执行测试用例，并将测试结果保存。

（4）测试固件：测试固件可以被简单理解为，在测试之前或者测试之后固定要做的一些动作。





###### 9.2.2 【实战】用 unitest 进行单元测试





（1）创建测试类



![image-20241002163207030](./assets/image-20241002163207030.png)



（2）创建测试用例



![image-20241002163244496](./assets/image-20241002163244496.png)



运行结果

![image-20241002163347094](./assets/image-20241002163347094.png)



（3）unitest 断言

在unittest框架中提供了很多断言方法，目的是检查测试的结果是否达到预期，并在断言失败后抛出失败的原因。



常见方法：

![image-20241002163414036](./assets/image-20241002163414036.png)





###### 9.2.3 【实战】用 HTMLTestRunner 生成 HTML 报告



一般都将测试结果生成HTML报告。



（1）创建 TestSuite

![image-20241002163539896](./assets/image-20241002163539896.png)



（2）使用 HTML 方式输出



![image-20241002163734103](./assets/image-20241002163734103.png)



![image-20241002163757801](./assets/image-20241002163757801.png)



新建脚本



![image-20241002163847555](./assets/image-20241002163847555.png)



执行

![image-20241002163904282](./assets/image-20241002163904282.png)



查看结果



![image-20241002163925799](./assets/image-20241002163925799.png)



可以的



###### 9.2.4 【实战】用 Pytest 进行单元测试



Pytest是一个非常成熟的、全功能的Python测试框架



1. 测试用例编写规则



- 测试文件以“test”开头或者“test”结尾。
- 测试类以“Test”开头，且不能带有init方法。
- 在测试类中可以包含一个或者多个以“test”开头的方法。
- 断言使用基本的assert方法即可。



2. 安装



![image-20241002164057606](./assets/image-20241002164057606.png)



![image-20241002164111473](./assets/image-20241002164111473.png)







3. 编写类文件



![image-20241002164304609](./assets/image-20241002164304609.png)



4. 编写测试类



![image-20241002164344534](./assets/image-20241002164344534.png)



5. 执行结果



![image-20241002164845839](./assets/image-20241002164845839.png)



测试报告



![image-20241002164920411](./assets/image-20241002164920411.png)



美观大方





###### 9.2.5 【实战】在 Django 中编写和运行测试用例



Django项目的所有应用中都有一个tests.py文件。可以在该文件中编写测试用例。



开一个新应用了 app9



![image-20241002165100691](./assets/image-20241002165100691.png)



![image-20241002165115458](./assets/image-20241002165115458.png)



就是这个



1. 编写测试用例



![image-20241002165320368](./assets/image-20241002165320368.png)



2. 执行测试用例



![image-20241002165400643](./assets/image-20241002165400643.png)



![image-20241002165408691](./assets/image-20241002165408691.png)



有一个测试用例执行完成，结果为 OK



3. 解决在 MySQL 中字符集不支持中文的错误



我这儿不用，我本身就是 utf-8



##### 9.3 接口自动化测试



接口自动化测试主要使用Postman工具，以及“Python+unittest'”编程方式。



###### 9.3.1 【实战】进行 Postman 测试



1. 发起 GET 请求



这里是做了权限控制，还挺麻烦，改成 basic 认证了



![image-20241002170036090](./assets/image-20241002170036090.png)



2. 发起 post 请求



![image-20241002170144332](./assets/image-20241002170144332.png)





###### 9.3.2 【实战】用 Requests + Pytest 实现接口自动化测试



1. 使用 Requests 库请求接口



![image-20241002170345093](./assets/image-20241002170345093.png)



不用装，已经有了



response 常用方法：

![image-20241002170423624](./assets/image-20241002170423624.png)



2. 编写接口测试用例



![image-20241002170722459](./assets/image-20241002170722459.png)



运行



![image-20241002170843505](./assets/image-20241002170843505-1727860123838-1.png)



这两个接口都能访问，这又自己改路由了



![image-20241002171451742](./assets/image-20241002171451742.png)



擦，他自己命名都不对



![image-20241002171607383](./assets/image-20241002171607383.png)



绿了





##### 9.4 用户界面自动化测试



用户界面自动化测试主要使用Selunium库。



###### 9.4.1 认识自动化测试 Selunium 库



Selenium库是一个免费的分布式的自动化测试工具，支持多平台、多浏览器、多语言。

Selenium库包含操纵浏览器进行各种操作动作，如打开新窗口、单击、双击、浏览器前进和后退、寻找下拉列表等。简单来说，Selenium库就是一个通过代码驱动，从而实现各种动作的浏览器。





###### 9.4.2 安装



![image-20241002171806229](./assets/image-20241002171806229.png)



![image-20241002171818045](./assets/image-20241002171818045.png)





由于它要调用浏览器，所以还需要一个驱动文件



https://chromedriver.storage.googleapis.com/index.html

![image-20241002172035098](./assets/image-20241002172035098.png)



只有 114 将就一下了，我的 Chrome 实在是太新了



![image-20241002172156947](./assets/image-20241002172156947.png)



试试能不能用了





###### 9.4.3 基本使用



![image-20241002172231417](./assets/image-20241002172231417.png)



运行试试



![image-20241002172447977](./assets/image-20241002172447977.png)

![image-20241002172615219](./assets/image-20241002172615219.png)



确实闪了一下啊，版本不行



https://googlechromelabs.github.io/chrome-for-testing/#stable



![image-20241002172815145](./assets/image-20241002172815145.png)



闪了一下啊，

![image-20241002172947539](./assets/image-20241002172947539.png)



没问题，确实出来了，但是会结束就关闭浏览器窗口了



![image-20241002173336744](./assets/image-20241002173336744.png)



睡 10 s 也行，拿到源代码就可以进一步分析了





###### 9.4.4 页面元素定位的方法



![image-20241002173418590](./assets/image-20241002173418590.png)



![image-20241002173541933](./assets/image-20241002173541933.png)



试试吧

![image-20241002173958428](./assets/image-20241002173958428.png)



可以的，3 版本系列可以，4 太新了，没有那个方法



###### 9.4.5 Selenium 库的高级用法



1. 模拟单击事件



![image-20241002174208476](./assets/image-20241002174208476.png)



可以的



2. 隐藏浏览器



如果不想看到弹出浏览器，则可以使用headless模式（即无界面模式)。



![image-20241002174352051](./assets/image-20241002174352051.png)



其实还是一闪而过了



![image-20241002174410684](./assets/image-20241002174410684.png)



只是啥也没出现就关闭了



3. 等待元素被加载





（1）隐式等待



![image-20241002174552222](./assets/image-20241002174552222.png)



（2）显示等待 【推荐】



![image-20241002174644216](./assets/image-20241002174644216.png)







4. 当前浏览器窗口进行截图



![image-20241002174748524](./assets/image-20241002174748524.png)



可以的

还可以网页长图



![image-20241002174904821](./assets/image-20241002174904821.png)



虽然效果一般



###### 9.4.6 【实战】自动化测试商城后台管理系统的登录页面



![image-20241002175821307](./assets/image-20241002175821307.png)



可以的，直接加入了





#### 第 10 章 基于 Redis 的缓存技术



##### 10.1 为什么需要缓存



为了避免多次查询这些数据带给数据库的压力，可以将这些较少发生改变且经常被查询的数据，在第1次查询后存放在缓存中：在第2次查询时，直接从缓存中获取。这样就不需要再从数据库中查询，极大地缓解了数据库的压力。



##### 10.2 用 Django 内置模块实现缓存



Django框架本身提供了完整的缓存系统，支持不同粒度的缓存。



Django 默认支持多种缓存方式：

- 本地内存（默认）
- 数据库
- 文件
- Memcached



###### 10.2.1 基于数据库方式实现缓存



.. 这  .. 都存到 MySQL里面了，还叫



配置

![image-20241002180231766](./assets/image-20241002180231766.png)



创建：

![image-20241002180328911](./assets/image-20241002180328911.png)



![image-20241002180345887](./assets/image-20241002180345887.png)



好好，真 · 用数据库做缓存





###### 10.2.1 缓存视图函数和视图类



1. 缓存视图函数



app6



![image-20241002180719958](./assets/image-20241002180719958.png)



配置路由

![image-20241002180746893](./assets/image-20241002180746893.png)



访问



![image-20241002180813111](./assets/image-20241002180813111.png)



![image-20241002180835849](./assets/image-20241002180835849.png)



看看数据库



![image-20241002180849564](./assets/image-20241002180849564.png)



好好，确实缓存进来， 60 s 之后



![image-20241002181005335](./assets/image-20241002181005335.png)



走的这张表，确实是没有查原表





2. 缓存视图类



![image-20241002181213242](./assets/image-20241002181213242.png)



路由



![image-20241002181248989](./assets/image-20241002181248989.png)



效果和视图函数一样



![image-20241002181352136](./assets/image-20241002181352136.png)



![image-20241002181404533](./assets/image-20241002181404533.png)



走的缓存这张表





##### 10.3 用 DRF 框架实现缓存



安装



![image-20241002181511754](./assets/image-20241002181511754.png)



###### 10.3.1 用装饰器完成缓存



app8



![image-20241002181648181](./assets/image-20241002181648181.png)



![image-20241002181733105](./assets/image-20241002181733105.png)



之前写的路由，看看效果



![image-20241002181824961](./assets/image-20241002181824961.png)



还是插入缓存表了



![image-20241002181848413](./assets/image-20241002181848413.png)



再访问就查缓存表



![image-20241002181908312](./assets/image-20241002181908312.png)



![image-20241002182121331](./assets/image-20241002182121331.png)



试试效果，但是视图类上的配置优先级更高,，先注掉



![image-20241002182245629](./assets/image-20241002182245629.png)



![image-20241002182606257](./assets/image-20241002182606257.png)



哦哦哦，不能注掉，就不给参数就行



![image-20241002182644778](./assets/image-20241002182644778.png)



没问题，300 s 生效了



###### 10.3.2 用 CacheResponseMixin 类完成缓存



drf-extensions包为缓存提供了3个扩展类



![image-20241002182750927](./assets/image-20241002182750927.png)



试试



![image-20241002182903026](./assets/image-20241002182903026.png)



效果



![image-20241002183002410](./assets/image-20241002183002410.png)



看看缓存







![image-20241002183022973](./assets/image-20241002183022973.png)



![image-20241002183037215](./assets/image-20241002183037215.png)



没问题



##### 10.4 用 Redis 实现缓存



Redis是一个完全开源免费的、遵守BSD协议、基于内存的、高性能的key-value的存储系统



###### 10.4.1 搭建 Redis 环境



我这里就用 现成的了，虽然版本有点新



![image-20241002183526593](./assets/image-20241002183526593.png)





###### 10.4.2 用 Django 操作 Redis



1. 安装 django-redis



![image-20241002183645445](./assets/image-20241002183645445.png)



![image-20241002183830777](./assets/image-20241002183830777.png)



版本稍微低一些



![image-20241002183910539](./assets/image-20241002183910539.png)



用这个



2. 配置



![image-20241002184202419](./assets/image-20241002184202419.png)



3. 使用



其实其他地方不用改都行，直接试试



![image-20241002184310231](./assets/image-20241002184310231.png)



没毛病，确实存进去了



![image-20241002184324573](./assets/image-20241002184324573.png)



过期时间 300 s

也可以直接 用 console 来测试一下



![image-20241002184455811](./assets/image-20241002184455811.png)





![image-20241002184525082](./assets/image-20241002184525082.png)



，没问题



###### 10.4.3 【实战】 用 Redis 存储 session 信息



Diango中的session共享，采用数据库或Redis来完成。在默认情况下，Django中的session信息是存储在数据库中的。在生成表结构时，会生成一张django_session表。





![image-20241002184729074](./assets/image-20241002184729074.png)



![image-20241002184844990](./assets/image-20241002184844990.png)



14 天过期



Django默认将session数据持久化到数据库中，其优缺点如下。

- 优点：当服务器宕机时，只要数据库没有损坏，则session就不会丢失。
- 缺点：如果网站有大量用户，每个用户登录都会保存一条数据，则在海量访问下会对数据库造成很大的压力。





用 Redis 怎么做



1. 安装 django-redis-sessions



![image-20241002185027529](./assets/image-20241002185027529.png)



2. 配置





![image-20241002185125541](./assets/image-20241002185125541.png)



好像没变啊



3. 测试



登录后台试试



![image-20241002185217182](./assets/image-20241002185217182.png)



不对，还是存到数据库了



![image-20241002185501014](./assets/image-20241002185501014.png)



这样才行



![image-20241002185544148](./assets/image-20241002185544148.png)



看看redis



![image-20241002185605620](./assets/image-20241002185605620.png)



没毛病



![image-20241002185620635](./assets/image-20241002185620635.png)



这下就没用这个表了

其实到这里感觉后端部分就差不多了【Django 后端部分就是这些了】



#### 第 4 篇 前台项目实战





#### 第 5 篇 部署运维



































